//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.x
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.x DataTemplate.g 2012-12-29 17:43:56

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

#pragma warning disable 3021

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace GBRead.Base
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.x")]
[System.CLSCompliant(false)]
public partial class DataTemplateParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARG", "ARRLEN", "BIN_DIGIT", "BIN_NUMBER", "COMMENT", "EXPRESSION", "FIXSTRING", "FORMAT", "FORMAT_ARG", "HEX_DIGIT", "HEX_NUMBER", "INT", "LITERAL", "NUMBER", "OCT_DIGIT", "OCT_NUMBER", "ROOT", "VARSTRING", "WS", "'!'", "'!='", "'%'", "'&&'", "'&'", "'('", "')'", "'*'", "'+'", "'-'", "'/'", "':'", "';'", "'<'", "'<<'", "'<='", "'=='", "'>'", "'>='", "'>>'", "'?'", "'['", "'\\''", "']'", "'^'", "'byte'", "'dword'", "'qword'", "'string'", "'word'", "'|'", "'||'", "'~'"
	};
	public const int EOF=-1;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int T__29=29;
	public const int T__30=30;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int ARG=4;
	public const int ARRLEN=5;
	public const int BIN_DIGIT=6;
	public const int BIN_NUMBER=7;
	public const int COMMENT=8;
	public const int EXPRESSION=9;
	public const int FIXSTRING=10;
	public const int FORMAT=11;
	public const int FORMAT_ARG=12;
	public const int HEX_DIGIT=13;
	public const int HEX_NUMBER=14;
	public const int INT=15;
	public const int LITERAL=16;
	public const int NUMBER=17;
	public const int OCT_DIGIT=18;
	public const int OCT_NUMBER=19;
	public const int ROOT=20;
	public const int VARSTRING=21;
	public const int WS=22;

	public DataTemplateParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public DataTemplateParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return DataTemplateParser.tokenNames; } }
	public override string GrammarFileName { get { return "DataTemplate.g"; } }


	private List<ErrInfo> Errors = new List<ErrInfo>();

	public override void DisplayRecognitionError(string[] tokenNames, RecognitionException e)
	{
		string errHeader = GetErrorHeader(e);
		string errMSG = GetErrorMessage(e, tokenNames);
		Errors.Add(new ErrInfo() {errText = errMSG, error = e});
	}

	public List<ErrInfo> GetErrors()
	{
		return Errors;
	}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_data_temp();
	partial void LeaveRule_data_temp();
	// $ANTLR start "data_temp"
	// DataTemplate.g:62:8: public data_temp : ( data_temp_line )* -> ^( ROOT ( data_temp_line )* ) ;
	[GrammarRule("data_temp")]
	public AstParserRuleReturnScope<CommonTree, IToken> data_temp()
	{
		EnterRule_data_temp();
		EnterRule("data_temp", 1);
		TraceIn("data_temp", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> data_temp_line1 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_data_temp_line=new RewriteRuleSubtreeStream(adaptor,"rule data_temp_line");
		try { DebugEnterRule(GrammarFileName, "data_temp");
		DebugLocation(62, 62);
		try
		{
			// DataTemplate.g:62:17: ( ( data_temp_line )* -> ^( ROOT ( data_temp_line )* ) )
			DebugEnterAlt(1);
			// DataTemplate.g:62:19: ( data_temp_line )*
			{
			DebugLocation(62, 19);
			// DataTemplate.g:62:19: ( data_temp_line )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>=48 && LA1_1<=52)))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// DataTemplate.g:62:20: data_temp_line
					{
					DebugLocation(62, 20);
					PushFollow(Follow._data_temp_line_in_data_temp119);
					data_temp_line1=data_temp_line();
					PopFollow();

					stream_data_temp_line.Add(data_temp_line1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: data_temp_line
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 62:37: -> ^( ROOT ( data_temp_line )* )
			{
				DebugLocation(62, 40);
				// DataTemplate.g:62:40: ^( ROOT ( data_temp_line )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(62, 42);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ROOT, "ROOT"), root_1);

				DebugLocation(62, 47);
				// DataTemplate.g:62:47: ( data_temp_line )*
				while ( stream_data_temp_line.HasNext )
				{
					DebugLocation(62, 47);
					adaptor.AddChild(root_1, stream_data_temp_line.NextTree());

				}
				stream_data_temp_line.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("data_temp", 1);
			LeaveRule("data_temp", 1);
			LeaveRule_data_temp();
		}
		DebugLocation(62, 62);
		} finally { DebugExitRule(GrammarFileName, "data_temp"); }
		return retval;

	}
	// $ANTLR end "data_temp"

	partial void EnterRule_data_temp_line();
	partial void LeaveRule_data_temp_line();
	// $ANTLR start "data_temp_line"
	// DataTemplate.g:64:1: data_temp_line : data_line_decl ';' !;
	[GrammarRule("data_temp_line")]
	private AstParserRuleReturnScope<CommonTree, IToken> data_temp_line()
	{
		EnterRule_data_temp_line();
		EnterRule("data_temp_line", 2);
		TraceIn("data_temp_line", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal3 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> data_line_decl2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal3_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "data_temp_line");
		DebugLocation(64, 36);
		try
		{
			// DataTemplate.g:64:16: ( data_line_decl ';' !)
			DebugEnterAlt(1);
			// DataTemplate.g:64:18: data_line_decl ';' !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(64, 18);
			PushFollow(Follow._data_line_decl_in_data_temp_line138);
			data_line_decl2=data_line_decl();
			PopFollow();

			adaptor.AddChild(root_0, data_line_decl2.Tree);
			DebugLocation(64, 36);
			char_literal3=(IToken)Match(input,35,Follow._35_in_data_temp_line140); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("data_temp_line", 2);
			LeaveRule("data_temp_line", 2);
			LeaveRule_data_temp_line();
		}
		DebugLocation(64, 36);
		} finally { DebugExitRule(GrammarFileName, "data_temp_line"); }
		return retval;

	}
	// $ANTLR end "data_temp_line"

	partial void EnterRule_data_line_decl();
	partial void LeaveRule_data_line_decl();
	// $ANTLR start "data_line_decl"
	// DataTemplate.g:66:1: data_line_decl : ( byte_decl | word_decl | dword_decl | qword_decl | string_decl );
	[GrammarRule("data_line_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> data_line_decl()
	{
		EnterRule_data_line_decl();
		EnterRule("data_line_decl", 3);
		TraceIn("data_line_decl", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> byte_decl4 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> word_decl5 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dword_decl6 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> qword_decl7 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> string_decl8 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "data_line_decl");
		DebugLocation(66, 17);
		try
		{
			// DataTemplate.g:66:16: ( byte_decl | word_decl | dword_decl | qword_decl | string_decl )
			int alt2=5;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case 48:
				{
				alt2 = 1;
				}
				break;
			case 52:
				{
				alt2 = 2;
				}
				break;
			case 49:
				{
				alt2 = 3;
				}
				break;
			case 50:
				{
				alt2 = 4;
				}
				break;
			case 51:
				{
				alt2 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:66:18: byte_decl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(66, 18);
				PushFollow(Follow._byte_decl_in_data_line_decl149);
				byte_decl4=byte_decl();
				PopFollow();

				adaptor.AddChild(root_0, byte_decl4.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// DataTemplate.g:67:7: word_decl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(67, 7);
				PushFollow(Follow._word_decl_in_data_line_decl157);
				word_decl5=word_decl();
				PopFollow();

				adaptor.AddChild(root_0, word_decl5.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// DataTemplate.g:68:7: dword_decl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(68, 7);
				PushFollow(Follow._dword_decl_in_data_line_decl165);
				dword_decl6=dword_decl();
				PopFollow();

				adaptor.AddChild(root_0, dword_decl6.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// DataTemplate.g:69:7: qword_decl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(69, 7);
				PushFollow(Follow._qword_decl_in_data_line_decl173);
				qword_decl7=qword_decl();
				PopFollow();

				adaptor.AddChild(root_0, qword_decl7.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// DataTemplate.g:70:7: string_decl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(70, 7);
				PushFollow(Follow._string_decl_in_data_line_decl181);
				string_decl8=string_decl();
				PopFollow();

				adaptor.AddChild(root_0, string_decl8.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("data_line_decl", 3);
			LeaveRule("data_line_decl", 3);
			LeaveRule_data_line_decl();
		}
		DebugLocation(70, 17);
		} finally { DebugExitRule(GrammarFileName, "data_line_decl"); }
		return retval;

	}
	// $ANTLR end "data_line_decl"

	partial void EnterRule_byte_decl();
	partial void LeaveRule_byte_decl();
	// $ANTLR start "byte_decl"
	// DataTemplate.g:72:1: byte_decl : 'byte' ^ ( func_decl )? ( arr_decl )? ;
	[GrammarRule("byte_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> byte_decl()
	{
		EnterRule_byte_decl();
		EnterRule("byte_decl", 4);
		TraceIn("byte_decl", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal9 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_decl10 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arr_decl11 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal9_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "byte_decl");
		DebugLocation(72, 41);
		try
		{
			// DataTemplate.g:72:12: ( 'byte' ^ ( func_decl )? ( arr_decl )? )
			DebugEnterAlt(1);
			// DataTemplate.g:72:14: 'byte' ^ ( func_decl )? ( arr_decl )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(72, 20);
			string_literal9=(IToken)Match(input,48,Follow._48_in_byte_decl190); 
			string_literal9_tree = (CommonTree)adaptor.Create(string_literal9);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal9_tree, root_0);
			DebugLocation(72, 22);
			// DataTemplate.g:72:22: ( func_decl )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==28))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:72:22: func_decl
				{
				DebugLocation(72, 22);
				PushFollow(Follow._func_decl_in_byte_decl193);
				func_decl10=func_decl();
				PopFollow();

				adaptor.AddChild(root_0, func_decl10.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(72, 33);
			// DataTemplate.g:72:33: ( arr_decl )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==44))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:72:33: arr_decl
				{
				DebugLocation(72, 33);
				PushFollow(Follow._arr_decl_in_byte_decl196);
				arr_decl11=arr_decl();
				PopFollow();

				adaptor.AddChild(root_0, arr_decl11.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("byte_decl", 4);
			LeaveRule("byte_decl", 4);
			LeaveRule_byte_decl();
		}
		DebugLocation(72, 41);
		} finally { DebugExitRule(GrammarFileName, "byte_decl"); }
		return retval;

	}
	// $ANTLR end "byte_decl"

	partial void EnterRule_word_decl();
	partial void LeaveRule_word_decl();
	// $ANTLR start "word_decl"
	// DataTemplate.g:73:1: word_decl : 'word' ^ ( func_decl )? ( arr_decl )? ;
	[GrammarRule("word_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> word_decl()
	{
		EnterRule_word_decl();
		EnterRule("word_decl", 5);
		TraceIn("word_decl", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal12 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_decl13 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arr_decl14 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal12_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "word_decl");
		DebugLocation(73, 41);
		try
		{
			// DataTemplate.g:73:12: ( 'word' ^ ( func_decl )? ( arr_decl )? )
			DebugEnterAlt(1);
			// DataTemplate.g:73:14: 'word' ^ ( func_decl )? ( arr_decl )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(73, 20);
			string_literal12=(IToken)Match(input,52,Follow._52_in_word_decl205); 
			string_literal12_tree = (CommonTree)adaptor.Create(string_literal12);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal12_tree, root_0);
			DebugLocation(73, 22);
			// DataTemplate.g:73:22: ( func_decl )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==28))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:73:22: func_decl
				{
				DebugLocation(73, 22);
				PushFollow(Follow._func_decl_in_word_decl208);
				func_decl13=func_decl();
				PopFollow();

				adaptor.AddChild(root_0, func_decl13.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(73, 33);
			// DataTemplate.g:73:33: ( arr_decl )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==44))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:73:33: arr_decl
				{
				DebugLocation(73, 33);
				PushFollow(Follow._arr_decl_in_word_decl211);
				arr_decl14=arr_decl();
				PopFollow();

				adaptor.AddChild(root_0, arr_decl14.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("word_decl", 5);
			LeaveRule("word_decl", 5);
			LeaveRule_word_decl();
		}
		DebugLocation(73, 41);
		} finally { DebugExitRule(GrammarFileName, "word_decl"); }
		return retval;

	}
	// $ANTLR end "word_decl"

	partial void EnterRule_dword_decl();
	partial void LeaveRule_dword_decl();
	// $ANTLR start "dword_decl"
	// DataTemplate.g:74:1: dword_decl : 'dword' ^ ( func_decl )? ( arr_decl )? ;
	[GrammarRule("dword_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> dword_decl()
	{
		EnterRule_dword_decl();
		EnterRule("dword_decl", 6);
		TraceIn("dword_decl", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal15 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_decl16 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arr_decl17 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal15_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "dword_decl");
		DebugLocation(74, 43);
		try
		{
			// DataTemplate.g:74:13: ( 'dword' ^ ( func_decl )? ( arr_decl )? )
			DebugEnterAlt(1);
			// DataTemplate.g:74:15: 'dword' ^ ( func_decl )? ( arr_decl )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(74, 22);
			string_literal15=(IToken)Match(input,49,Follow._49_in_dword_decl220); 
			string_literal15_tree = (CommonTree)adaptor.Create(string_literal15);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal15_tree, root_0);
			DebugLocation(74, 24);
			// DataTemplate.g:74:24: ( func_decl )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==28))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:74:24: func_decl
				{
				DebugLocation(74, 24);
				PushFollow(Follow._func_decl_in_dword_decl223);
				func_decl16=func_decl();
				PopFollow();

				adaptor.AddChild(root_0, func_decl16.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(74, 35);
			// DataTemplate.g:74:35: ( arr_decl )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==44))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:74:35: arr_decl
				{
				DebugLocation(74, 35);
				PushFollow(Follow._arr_decl_in_dword_decl226);
				arr_decl17=arr_decl();
				PopFollow();

				adaptor.AddChild(root_0, arr_decl17.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dword_decl", 6);
			LeaveRule("dword_decl", 6);
			LeaveRule_dword_decl();
		}
		DebugLocation(74, 43);
		} finally { DebugExitRule(GrammarFileName, "dword_decl"); }
		return retval;

	}
	// $ANTLR end "dword_decl"

	partial void EnterRule_qword_decl();
	partial void LeaveRule_qword_decl();
	// $ANTLR start "qword_decl"
	// DataTemplate.g:75:1: qword_decl : 'qword' ^ ( func_decl )? ( arr_decl )? ;
	[GrammarRule("qword_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> qword_decl()
	{
		EnterRule_qword_decl();
		EnterRule("qword_decl", 7);
		TraceIn("qword_decl", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal18 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_decl19 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arr_decl20 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal18_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "qword_decl");
		DebugLocation(75, 43);
		try
		{
			// DataTemplate.g:75:13: ( 'qword' ^ ( func_decl )? ( arr_decl )? )
			DebugEnterAlt(1);
			// DataTemplate.g:75:15: 'qword' ^ ( func_decl )? ( arr_decl )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(75, 22);
			string_literal18=(IToken)Match(input,50,Follow._50_in_qword_decl235); 
			string_literal18_tree = (CommonTree)adaptor.Create(string_literal18);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal18_tree, root_0);
			DebugLocation(75, 24);
			// DataTemplate.g:75:24: ( func_decl )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==28))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:75:24: func_decl
				{
				DebugLocation(75, 24);
				PushFollow(Follow._func_decl_in_qword_decl238);
				func_decl19=func_decl();
				PopFollow();

				adaptor.AddChild(root_0, func_decl19.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(75, 35);
			// DataTemplate.g:75:35: ( arr_decl )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==44))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:75:35: arr_decl
				{
				DebugLocation(75, 35);
				PushFollow(Follow._arr_decl_in_qword_decl241);
				arr_decl20=arr_decl();
				PopFollow();

				adaptor.AddChild(root_0, arr_decl20.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("qword_decl", 7);
			LeaveRule("qword_decl", 7);
			LeaveRule_qword_decl();
		}
		DebugLocation(75, 43);
		} finally { DebugExitRule(GrammarFileName, "qword_decl"); }
		return retval;

	}
	// $ANTLR end "qword_decl"

	partial void EnterRule_string_decl();
	partial void LeaveRule_string_decl();
	// $ANTLR start "string_decl"
	// DataTemplate.g:76:1: string_decl : 'string' ^ ( string_fdecl )? ( arr_decl )? ;
	[GrammarRule("string_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> string_decl()
	{
		EnterRule_string_decl();
		EnterRule("string_decl", 8);
		TraceIn("string_decl", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal21 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> string_fdecl22 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arr_decl23 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal21_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "string_decl");
		DebugLocation(76, 48);
		try
		{
			// DataTemplate.g:76:14: ( 'string' ^ ( string_fdecl )? ( arr_decl )? )
			DebugEnterAlt(1);
			// DataTemplate.g:76:16: 'string' ^ ( string_fdecl )? ( arr_decl )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(76, 24);
			string_literal21=(IToken)Match(input,51,Follow._51_in_string_decl250); 
			string_literal21_tree = (CommonTree)adaptor.Create(string_literal21);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal21_tree, root_0);
			DebugLocation(76, 26);
			// DataTemplate.g:76:26: ( string_fdecl )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==28))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:76:26: string_fdecl
				{
				DebugLocation(76, 26);
				PushFollow(Follow._string_fdecl_in_string_decl253);
				string_fdecl22=string_fdecl();
				PopFollow();

				adaptor.AddChild(root_0, string_fdecl22.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(76, 40);
			// DataTemplate.g:76:40: ( arr_decl )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1==44))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:76:40: arr_decl
				{
				DebugLocation(76, 40);
				PushFollow(Follow._arr_decl_in_string_decl256);
				arr_decl23=arr_decl();
				PopFollow();

				adaptor.AddChild(root_0, arr_decl23.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("string_decl", 8);
			LeaveRule("string_decl", 8);
			LeaveRule_string_decl();
		}
		DebugLocation(76, 48);
		} finally { DebugExitRule(GrammarFileName, "string_decl"); }
		return retval;

	}
	// $ANTLR end "string_decl"

	partial void EnterRule_string_fdecl();
	partial void LeaveRule_string_fdecl();
	// $ANTLR start "string_fdecl"
	// DataTemplate.g:78:1: string_fdecl : '(' expression ')' -> ^( ARG expression ) ;
	[GrammarRule("string_fdecl")]
	private AstParserRuleReturnScope<CommonTree, IToken> string_fdecl()
	{
		EnterRule_string_fdecl();
		EnterRule("string_fdecl", 9);
		TraceIn("string_fdecl", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal24 = default(IToken);
		IToken char_literal26 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression25 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal24_tree = default(CommonTree);
		CommonTree char_literal26_tree = default(CommonTree);
		RewriteRuleITokenStream stream_28=new RewriteRuleITokenStream(adaptor,"token 28");
		RewriteRuleITokenStream stream_29=new RewriteRuleITokenStream(adaptor,"token 29");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "string_fdecl");
		DebugLocation(78, 54);
		try
		{
			// DataTemplate.g:78:14: ( '(' expression ')' -> ^( ARG expression ) )
			DebugEnterAlt(1);
			// DataTemplate.g:78:16: '(' expression ')'
			{
			DebugLocation(78, 16);
			char_literal24=(IToken)Match(input,28,Follow._28_in_string_fdecl265);  
			stream_28.Add(char_literal24);

			DebugLocation(78, 20);
			PushFollow(Follow._expression_in_string_fdecl267);
			expression25=expression();
			PopFollow();

			stream_expression.Add(expression25.Tree);
			DebugLocation(78, 31);
			char_literal26=(IToken)Match(input,29,Follow._29_in_string_fdecl269);  
			stream_29.Add(char_literal26);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 78:35: -> ^( ARG expression )
			{
				DebugLocation(78, 38);
				// DataTemplate.g:78:38: ^( ARG expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(78, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(78, 44);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("string_fdecl", 9);
			LeaveRule("string_fdecl", 9);
			LeaveRule_string_fdecl();
		}
		DebugLocation(78, 54);
		} finally { DebugExitRule(GrammarFileName, "string_fdecl"); }
		return retval;

	}
	// $ANTLR end "string_fdecl"

	partial void EnterRule_func_decl();
	partial void LeaveRule_func_decl();
	// $ANTLR start "func_decl"
	// DataTemplate.g:79:1: func_decl : '(' format_type ')' -> ^( ARG format_type ) ;
	[GrammarRule("func_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> func_decl()
	{
		EnterRule_func_decl();
		EnterRule("func_decl", 10);
		TraceIn("func_decl", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal27 = default(IToken);
		IToken char_literal29 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> format_type28 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal27_tree = default(CommonTree);
		CommonTree char_literal29_tree = default(CommonTree);
		RewriteRuleITokenStream stream_28=new RewriteRuleITokenStream(adaptor,"token 28");
		RewriteRuleITokenStream stream_29=new RewriteRuleITokenStream(adaptor,"token 29");
		RewriteRuleSubtreeStream stream_format_type=new RewriteRuleSubtreeStream(adaptor,"rule format_type");
		try { DebugEnterRule(GrammarFileName, "func_decl");
		DebugLocation(79, 54);
		try
		{
			// DataTemplate.g:79:12: ( '(' format_type ')' -> ^( ARG format_type ) )
			DebugEnterAlt(1);
			// DataTemplate.g:79:14: '(' format_type ')'
			{
			DebugLocation(79, 14);
			char_literal27=(IToken)Match(input,28,Follow._28_in_func_decl285);  
			stream_28.Add(char_literal27);

			DebugLocation(79, 18);
			PushFollow(Follow._format_type_in_func_decl287);
			format_type28=format_type();
			PopFollow();

			stream_format_type.Add(format_type28.Tree);
			DebugLocation(79, 30);
			char_literal29=(IToken)Match(input,29,Follow._29_in_func_decl289);  
			stream_29.Add(char_literal29);



			{
			// AST REWRITE
			// elements: format_type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 79:34: -> ^( ARG format_type )
			{
				DebugLocation(79, 37);
				// DataTemplate.g:79:37: ^( ARG format_type )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(79, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(79, 43);
				adaptor.AddChild(root_1, stream_format_type.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("func_decl", 10);
			LeaveRule("func_decl", 10);
			LeaveRule_func_decl();
		}
		DebugLocation(79, 54);
		} finally { DebugExitRule(GrammarFileName, "func_decl"); }
		return retval;

	}
	// $ANTLR end "func_decl"

	partial void EnterRule_arr_decl();
	partial void LeaveRule_arr_decl();
	// $ANTLR start "arr_decl"
	// DataTemplate.g:81:1: arr_decl : '[' expression ']' -> ^( ARRLEN expression ) ;
	[GrammarRule("arr_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> arr_decl()
	{
		EnterRule_arr_decl();
		EnterRule("arr_decl", 11);
		TraceIn("arr_decl", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal30 = default(IToken);
		IToken char_literal32 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression31 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal30_tree = default(CommonTree);
		CommonTree char_literal32_tree = default(CommonTree);
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "arr_decl");
		DebugLocation(81, 54);
		try
		{
			// DataTemplate.g:81:11: ( '[' expression ']' -> ^( ARRLEN expression ) )
			DebugEnterAlt(1);
			// DataTemplate.g:81:13: '[' expression ']'
			{
			DebugLocation(81, 13);
			char_literal30=(IToken)Match(input,44,Follow._44_in_arr_decl306);  
			stream_44.Add(char_literal30);

			DebugLocation(81, 17);
			PushFollow(Follow._expression_in_arr_decl308);
			expression31=expression();
			PopFollow();

			stream_expression.Add(expression31.Tree);
			DebugLocation(81, 28);
			char_literal32=(IToken)Match(input,46,Follow._46_in_arr_decl310);  
			stream_46.Add(char_literal32);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 81:32: -> ^( ARRLEN expression )
			{
				DebugLocation(81, 35);
				// DataTemplate.g:81:35: ^( ARRLEN expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(81, 37);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARRLEN, "ARRLEN"), root_1);

				DebugLocation(81, 44);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arr_decl", 11);
			LeaveRule("arr_decl", 11);
			LeaveRule_arr_decl();
		}
		DebugLocation(81, 54);
		} finally { DebugExitRule(GrammarFileName, "arr_decl"); }
		return retval;

	}
	// $ANTLR end "arr_decl"

	partial void EnterRule_format_type();
	partial void LeaveRule_format_type();
	// $ANTLR start "format_type"
	// DataTemplate.g:83:1: format_type : format_arg -> ^( FORMAT format_arg ) ;
	[GrammarRule("format_type")]
	private AstParserRuleReturnScope<CommonTree, IToken> format_type()
	{
		EnterRule_format_type();
		EnterRule("format_type", 12);
		TraceIn("format_type", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> format_arg33 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_format_arg=new RewriteRuleSubtreeStream(adaptor,"rule format_arg");
		try { DebugEnterRule(GrammarFileName, "format_type");
		DebugLocation(83, 49);
		try
		{
			// DataTemplate.g:83:14: ( format_arg -> ^( FORMAT format_arg ) )
			DebugEnterAlt(1);
			// DataTemplate.g:83:16: format_arg
			{
			DebugLocation(83, 16);
			PushFollow(Follow._format_arg_in_format_type327);
			format_arg33=format_arg();
			PopFollow();

			stream_format_arg.Add(format_arg33.Tree);


			{
			// AST REWRITE
			// elements: format_arg
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 83:27: -> ^( FORMAT format_arg )
			{
				DebugLocation(83, 30);
				// DataTemplate.g:83:30: ^( FORMAT format_arg )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(83, 32);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FORMAT, "FORMAT"), root_1);

				DebugLocation(83, 39);
				adaptor.AddChild(root_1, stream_format_arg.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("format_type", 12);
			LeaveRule("format_type", 12);
			LeaveRule_format_type();
		}
		DebugLocation(83, 49);
		} finally { DebugExitRule(GrammarFileName, "format_type"); }
		return retval;

	}
	// $ANTLR end "format_type"

	partial void EnterRule_format_arg();
	partial void LeaveRule_format_arg();
	// $ANTLR start "format_arg"
	// DataTemplate.g:85:1: format_arg : '\\'' ! FORMAT_ARG '\\'' !;
	[GrammarRule("format_arg")]
	private AstParserRuleReturnScope<CommonTree, IToken> format_arg()
	{
		EnterRule_format_arg();
		EnterRule("format_arg", 13);
		TraceIn("format_arg", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal34 = default(IToken);
		IToken FORMAT_ARG35 = default(IToken);
		IToken char_literal36 = default(IToken);

		CommonTree char_literal34_tree = default(CommonTree);
		CommonTree FORMAT_ARG35_tree = default(CommonTree);
		CommonTree char_literal36_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "format_arg");
		DebugLocation(85, 36);
		try
		{
			// DataTemplate.g:85:13: ( '\\'' ! FORMAT_ARG '\\'' !)
			DebugEnterAlt(1);
			// DataTemplate.g:85:15: '\\'' ! FORMAT_ARG '\\'' !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(85, 19);
			char_literal34=(IToken)Match(input,45,Follow._45_in_format_arg344); 
			DebugLocation(85, 21);
			FORMAT_ARG35=(IToken)Match(input,FORMAT_ARG,Follow._FORMAT_ARG_in_format_arg347); 
			FORMAT_ARG35_tree = (CommonTree)adaptor.Create(FORMAT_ARG35);
			adaptor.AddChild(root_0, FORMAT_ARG35_tree);
			DebugLocation(85, 36);
			char_literal36=(IToken)Match(input,45,Follow._45_in_format_arg349); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("format_arg", 13);
			LeaveRule("format_arg", 13);
			LeaveRule_format_arg();
		}
		DebugLocation(85, 36);
		} finally { DebugExitRule(GrammarFileName, "format_arg"); }
		return retval;

	}
	// $ANTLR end "format_arg"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// DataTemplate.g:89:1: expression : cond_exp -> ^( EXPRESSION cond_exp ) ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 14);
		TraceIn("expression", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> cond_exp37 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_cond_exp=new RewriteRuleSubtreeStream(adaptor,"rule cond_exp");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(89, 48);
		try
		{
			// DataTemplate.g:89:13: ( cond_exp -> ^( EXPRESSION cond_exp ) )
			DebugEnterAlt(1);
			// DataTemplate.g:89:15: cond_exp
			{
			DebugLocation(89, 15);
			PushFollow(Follow._cond_exp_in_expression379);
			cond_exp37=cond_exp();
			PopFollow();

			stream_cond_exp.Add(cond_exp37.Tree);


			{
			// AST REWRITE
			// elements: cond_exp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 89:24: -> ^( EXPRESSION cond_exp )
			{
				DebugLocation(89, 27);
				// DataTemplate.g:89:27: ^( EXPRESSION cond_exp )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(89, 29);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXPRESSION, "EXPRESSION"), root_1);

				DebugLocation(89, 40);
				adaptor.AddChild(root_1, stream_cond_exp.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 14);
			LeaveRule("expression", 14);
			LeaveRule_expression();
		}
		DebugLocation(89, 48);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_cond_exp();
	partial void LeaveRule_cond_exp();
	// $ANTLR start "cond_exp"
	// DataTemplate.g:91:1: cond_exp : bool_or_exp ( '?' ^ cond_exp ':' ! cond_exp )? ;
	[GrammarRule("cond_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> cond_exp()
	{
		EnterRule_cond_exp();
		EnterRule("cond_exp", 15);
		TraceIn("cond_exp", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal39 = default(IToken);
		IToken char_literal41 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bool_or_exp38 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> cond_exp40 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> cond_exp42 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal39_tree = default(CommonTree);
		CommonTree char_literal41_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "cond_exp");
		DebugLocation(91, 58);
		try
		{
			// DataTemplate.g:91:11: ( bool_or_exp ( '?' ^ cond_exp ':' ! cond_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:91:13: bool_or_exp ( '?' ^ cond_exp ':' ! cond_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(91, 13);
			PushFollow(Follow._bool_or_exp_in_cond_exp396);
			bool_or_exp38=bool_or_exp();
			PopFollow();

			adaptor.AddChild(root_0, bool_or_exp38.Tree);
			DebugLocation(91, 25);
			// DataTemplate.g:91:25: ( '?' ^ cond_exp ':' ! cond_exp )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==43))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:91:26: '?' ^ cond_exp ':' ! cond_exp
				{
				DebugLocation(91, 29);
				char_literal39=(IToken)Match(input,43,Follow._43_in_cond_exp399); 
				char_literal39_tree = (CommonTree)adaptor.Create(char_literal39);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal39_tree, root_0);
				DebugLocation(91, 35);
				PushFollow(Follow._cond_exp_in_cond_exp406);
				cond_exp40=cond_exp();
				PopFollow();

				adaptor.AddChild(root_0, cond_exp40.Tree);
				DebugLocation(91, 47);
				char_literal41=(IToken)Match(input,34,Follow._34_in_cond_exp408); 
				DebugLocation(91, 49);
				PushFollow(Follow._cond_exp_in_cond_exp411);
				cond_exp42=cond_exp();
				PopFollow();

				adaptor.AddChild(root_0, cond_exp42.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("cond_exp", 15);
			LeaveRule("cond_exp", 15);
			LeaveRule_cond_exp();
		}
		DebugLocation(91, 58);
		} finally { DebugExitRule(GrammarFileName, "cond_exp"); }
		return retval;

	}
	// $ANTLR end "cond_exp"

	partial void EnterRule_bool_or_exp();
	partial void LeaveRule_bool_or_exp();
	// $ANTLR start "bool_or_exp"
	// DataTemplate.g:92:1: bool_or_exp : bool_and_exp ( '||' ^ bool_or_exp )? ;
	[GrammarRule("bool_or_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> bool_or_exp()
	{
		EnterRule_bool_or_exp();
		EnterRule("bool_or_exp", 16);
		TraceIn("bool_or_exp", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal44 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bool_and_exp43 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bool_or_exp45 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal44_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bool_or_exp");
		DebugLocation(92, 51);
		try
		{
			// DataTemplate.g:92:14: ( bool_and_exp ( '||' ^ bool_or_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:92:16: bool_and_exp ( '||' ^ bool_or_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(92, 16);
			PushFollow(Follow._bool_and_exp_in_bool_or_exp421);
			bool_and_exp43=bool_and_exp();
			PopFollow();

			adaptor.AddChild(root_0, bool_and_exp43.Tree);
			DebugLocation(92, 28);
			// DataTemplate.g:92:28: ( '||' ^ bool_or_exp )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==54))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:92:29: '||' ^ bool_or_exp
				{
				DebugLocation(92, 33);
				string_literal44=(IToken)Match(input,54,Follow._54_in_bool_or_exp423); 
				string_literal44_tree = (CommonTree)adaptor.Create(string_literal44);
				root_0 = (CommonTree)adaptor.BecomeRoot(string_literal44_tree, root_0);
				DebugLocation(92, 39);
				PushFollow(Follow._bool_or_exp_in_bool_or_exp430);
				bool_or_exp45=bool_or_exp();
				PopFollow();

				adaptor.AddChild(root_0, bool_or_exp45.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bool_or_exp", 16);
			LeaveRule("bool_or_exp", 16);
			LeaveRule_bool_or_exp();
		}
		DebugLocation(92, 51);
		} finally { DebugExitRule(GrammarFileName, "bool_or_exp"); }
		return retval;

	}
	// $ANTLR end "bool_or_exp"

	partial void EnterRule_bool_and_exp();
	partial void LeaveRule_bool_and_exp();
	// $ANTLR start "bool_and_exp"
	// DataTemplate.g:93:1: bool_and_exp : or_exp ( '&&' ^ bool_and_exp )? ;
	[GrammarRule("bool_and_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> bool_and_exp()
	{
		EnterRule_bool_and_exp();
		EnterRule("bool_and_exp", 17);
		TraceIn("bool_and_exp", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal47 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> or_exp46 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bool_and_exp48 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal47_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bool_and_exp");
		DebugLocation(93, 48);
		try
		{
			// DataTemplate.g:93:14: ( or_exp ( '&&' ^ bool_and_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:93:16: or_exp ( '&&' ^ bool_and_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(93, 16);
			PushFollow(Follow._or_exp_in_bool_and_exp439);
			or_exp46=or_exp();
			PopFollow();

			adaptor.AddChild(root_0, or_exp46.Tree);
			DebugLocation(93, 24);
			// DataTemplate.g:93:24: ( '&&' ^ bool_and_exp )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==26))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:93:25: '&&' ^ bool_and_exp
				{
				DebugLocation(93, 29);
				string_literal47=(IToken)Match(input,26,Follow._26_in_bool_and_exp443); 
				string_literal47_tree = (CommonTree)adaptor.Create(string_literal47);
				root_0 = (CommonTree)adaptor.BecomeRoot(string_literal47_tree, root_0);
				DebugLocation(93, 35);
				PushFollow(Follow._bool_and_exp_in_bool_and_exp450);
				bool_and_exp48=bool_and_exp();
				PopFollow();

				adaptor.AddChild(root_0, bool_and_exp48.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bool_and_exp", 17);
			LeaveRule("bool_and_exp", 17);
			LeaveRule_bool_and_exp();
		}
		DebugLocation(93, 48);
		} finally { DebugExitRule(GrammarFileName, "bool_and_exp"); }
		return retval;

	}
	// $ANTLR end "bool_and_exp"

	partial void EnterRule_or_exp();
	partial void LeaveRule_or_exp();
	// $ANTLR start "or_exp"
	// DataTemplate.g:94:1: or_exp : xor_exp ( '|' ^ or_exp )? ;
	[GrammarRule("or_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> or_exp()
	{
		EnterRule_or_exp();
		EnterRule("or_exp", 18);
		TraceIn("or_exp", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal50 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> xor_exp49 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> or_exp51 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal50_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "or_exp");
		DebugLocation(94, 38);
		try
		{
			// DataTemplate.g:94:10: ( xor_exp ( '|' ^ or_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:94:12: xor_exp ( '|' ^ or_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(94, 12);
			PushFollow(Follow._xor_exp_in_or_exp461);
			xor_exp49=xor_exp();
			PopFollow();

			adaptor.AddChild(root_0, xor_exp49.Tree);
			DebugLocation(94, 21);
			// DataTemplate.g:94:21: ( '|' ^ or_exp )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==53))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:94:22: '|' ^ or_exp
				{
				DebugLocation(94, 25);
				char_literal50=(IToken)Match(input,53,Follow._53_in_or_exp465); 
				char_literal50_tree = (CommonTree)adaptor.Create(char_literal50);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal50_tree, root_0);
				DebugLocation(94, 31);
				PushFollow(Follow._or_exp_in_or_exp472);
				or_exp51=or_exp();
				PopFollow();

				adaptor.AddChild(root_0, or_exp51.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("or_exp", 18);
			LeaveRule("or_exp", 18);
			LeaveRule_or_exp();
		}
		DebugLocation(94, 38);
		} finally { DebugExitRule(GrammarFileName, "or_exp"); }
		return retval;

	}
	// $ANTLR end "or_exp"

	partial void EnterRule_xor_exp();
	partial void LeaveRule_xor_exp();
	// $ANTLR start "xor_exp"
	// DataTemplate.g:95:1: xor_exp : and_exp ( '^' ^ xor_exp )? ;
	[GrammarRule("xor_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> xor_exp()
	{
		EnterRule_xor_exp();
		EnterRule("xor_exp", 19);
		TraceIn("xor_exp", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal53 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> and_exp52 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> xor_exp54 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal53_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "xor_exp");
		DebugLocation(95, 40);
		try
		{
			// DataTemplate.g:95:11: ( and_exp ( '^' ^ xor_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:95:13: and_exp ( '^' ^ xor_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(95, 13);
			PushFollow(Follow._and_exp_in_xor_exp483);
			and_exp52=and_exp();
			PopFollow();

			adaptor.AddChild(root_0, and_exp52.Tree);
			DebugLocation(95, 22);
			// DataTemplate.g:95:22: ( '^' ^ xor_exp )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==47))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:95:23: '^' ^ xor_exp
				{
				DebugLocation(95, 26);
				char_literal53=(IToken)Match(input,47,Follow._47_in_xor_exp487); 
				char_literal53_tree = (CommonTree)adaptor.Create(char_literal53);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal53_tree, root_0);
				DebugLocation(95, 32);
				PushFollow(Follow._xor_exp_in_xor_exp494);
				xor_exp54=xor_exp();
				PopFollow();

				adaptor.AddChild(root_0, xor_exp54.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xor_exp", 19);
			LeaveRule("xor_exp", 19);
			LeaveRule_xor_exp();
		}
		DebugLocation(95, 40);
		} finally { DebugExitRule(GrammarFileName, "xor_exp"); }
		return retval;

	}
	// $ANTLR end "xor_exp"

	partial void EnterRule_and_exp();
	partial void LeaveRule_and_exp();
	// $ANTLR start "and_exp"
	// DataTemplate.g:96:1: and_exp : equals_exp ( '&' ^ and_exp )? ;
	[GrammarRule("and_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> and_exp()
	{
		EnterRule_and_exp();
		EnterRule("and_exp", 20);
		TraceIn("and_exp", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal56 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> equals_exp55 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> and_exp57 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal56_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "and_exp");
		DebugLocation(96, 42);
		try
		{
			// DataTemplate.g:96:11: ( equals_exp ( '&' ^ and_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:96:13: equals_exp ( '&' ^ and_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(96, 13);
			PushFollow(Follow._equals_exp_in_and_exp505);
			equals_exp55=equals_exp();
			PopFollow();

			adaptor.AddChild(root_0, equals_exp55.Tree);
			DebugLocation(96, 24);
			// DataTemplate.g:96:24: ( '&' ^ and_exp )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==27))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:96:25: '&' ^ and_exp
				{
				DebugLocation(96, 28);
				char_literal56=(IToken)Match(input,27,Follow._27_in_and_exp508); 
				char_literal56_tree = (CommonTree)adaptor.Create(char_literal56);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal56_tree, root_0);
				DebugLocation(96, 34);
				PushFollow(Follow._and_exp_in_and_exp515);
				and_exp57=and_exp();
				PopFollow();

				adaptor.AddChild(root_0, and_exp57.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("and_exp", 20);
			LeaveRule("and_exp", 20);
			LeaveRule_and_exp();
		}
		DebugLocation(96, 42);
		} finally { DebugExitRule(GrammarFileName, "and_exp"); }
		return retval;

	}
	// $ANTLR end "and_exp"

	partial void EnterRule_equals_exp();
	partial void LeaveRule_equals_exp();
	// $ANTLR start "equals_exp"
	// DataTemplate.g:97:1: equals_exp : compare_exp ( ( '==' | '!=' ) ^ equals_exp )? ;
	[GrammarRule("equals_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> equals_exp()
	{
		EnterRule_equals_exp();
		EnterRule("equals_exp", 21);
		TraceIn("equals_exp", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set59 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> compare_exp58 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> equals_exp60 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set59_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "equals_exp");
		DebugLocation(97, 54);
		try
		{
			// DataTemplate.g:97:13: ( compare_exp ( ( '==' | '!=' ) ^ equals_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:97:15: compare_exp ( ( '==' | '!=' ) ^ equals_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(97, 15);
			PushFollow(Follow._compare_exp_in_equals_exp525);
			compare_exp58=compare_exp();
			PopFollow();

			adaptor.AddChild(root_0, compare_exp58.Tree);
			DebugLocation(97, 27);
			// DataTemplate.g:97:27: ( ( '==' | '!=' ) ^ equals_exp )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_1 = input.LA(1);

			if ((LA19_1==24||LA19_1==39))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:97:28: ( '==' | '!=' ) ^ equals_exp
				{
				DebugLocation(97, 39);

				set59=(IToken)input.LT(1);
				set59=(IToken)input.LT(1);
				if (input.LA(1)==24||input.LA(1)==39)
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set59), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(97, 43);
				PushFollow(Follow._equals_exp_in_equals_exp537);
				equals_exp60=equals_exp();
				PopFollow();

				adaptor.AddChild(root_0, equals_exp60.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equals_exp", 21);
			LeaveRule("equals_exp", 21);
			LeaveRule_equals_exp();
		}
		DebugLocation(97, 54);
		} finally { DebugExitRule(GrammarFileName, "equals_exp"); }
		return retval;

	}
	// $ANTLR end "equals_exp"

	partial void EnterRule_compare_exp();
	partial void LeaveRule_compare_exp();
	// $ANTLR start "compare_exp"
	// DataTemplate.g:98:1: compare_exp : shift_exp ( ( '<' | '>' | '<=' | '>=' ) ^ compare_exp )? ;
	[GrammarRule("compare_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> compare_exp()
	{
		EnterRule_compare_exp();
		EnterRule("compare_exp", 22);
		TraceIn("compare_exp", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set62 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> shift_exp61 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> compare_exp63 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set62_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "compare_exp");
		DebugLocation(98, 60);
		try
		{
			// DataTemplate.g:98:14: ( shift_exp ( ( '<' | '>' | '<=' | '>=' ) ^ compare_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:98:16: shift_exp ( ( '<' | '>' | '<=' | '>=' ) ^ compare_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(98, 16);
			PushFollow(Follow._shift_exp_in_compare_exp547);
			shift_exp61=shift_exp();
			PopFollow();

			adaptor.AddChild(root_0, shift_exp61.Tree);
			DebugLocation(98, 26);
			// DataTemplate.g:98:26: ( ( '<' | '>' | '<=' | '>=' ) ^ compare_exp )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==36||LA20_1==38||(LA20_1>=40 && LA20_1<=41)))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:98:27: ( '<' | '>' | '<=' | '>=' ) ^ compare_exp
				{
				DebugLocation(98, 46);

				set62=(IToken)input.LT(1);
				set62=(IToken)input.LT(1);
				if (input.LA(1)==36||input.LA(1)==38||(input.LA(1)>=40 && input.LA(1)<=41))
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set62), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(98, 48);
				PushFollow(Follow._compare_exp_in_compare_exp561);
				compare_exp63=compare_exp();
				PopFollow();

				adaptor.AddChild(root_0, compare_exp63.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compare_exp", 22);
			LeaveRule("compare_exp", 22);
			LeaveRule_compare_exp();
		}
		DebugLocation(98, 60);
		} finally { DebugExitRule(GrammarFileName, "compare_exp"); }
		return retval;

	}
	// $ANTLR end "compare_exp"

	partial void EnterRule_shift_exp();
	partial void LeaveRule_shift_exp();
	// $ANTLR start "shift_exp"
	// DataTemplate.g:99:1: shift_exp : add_exp ( ( '<<' | '>>' ) ^ shift_exp )? ;
	[GrammarRule("shift_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> shift_exp()
	{
		EnterRule_shift_exp();
		EnterRule("shift_exp", 23);
		TraceIn("shift_exp", 23);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set65 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> add_exp64 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> shift_exp66 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set65_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "shift_exp");
		DebugLocation(99, 49);
		try
		{
			// DataTemplate.g:99:12: ( add_exp ( ( '<<' | '>>' ) ^ shift_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:99:14: add_exp ( ( '<<' | '>>' ) ^ shift_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(99, 14);
			PushFollow(Follow._add_exp_in_shift_exp571);
			add_exp64=add_exp();
			PopFollow();

			adaptor.AddChild(root_0, add_exp64.Tree);
			DebugLocation(99, 23);
			// DataTemplate.g:99:23: ( ( '<<' | '>>' ) ^ shift_exp )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if ((LA21_1==37||LA21_1==42))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:99:24: ( '<<' | '>>' ) ^ shift_exp
				{
				DebugLocation(99, 35);

				set65=(IToken)input.LT(1);
				set65=(IToken)input.LT(1);
				if (input.LA(1)==37||input.LA(1)==42)
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set65), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(99, 39);
				PushFollow(Follow._shift_exp_in_shift_exp584);
				shift_exp66=shift_exp();
				PopFollow();

				adaptor.AddChild(root_0, shift_exp66.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shift_exp", 23);
			LeaveRule("shift_exp", 23);
			LeaveRule_shift_exp();
		}
		DebugLocation(99, 49);
		} finally { DebugExitRule(GrammarFileName, "shift_exp"); }
		return retval;

	}
	// $ANTLR end "shift_exp"

	partial void EnterRule_add_exp();
	partial void LeaveRule_add_exp();
	// $ANTLR start "add_exp"
	// DataTemplate.g:100:1: add_exp : multiply_exp ( ( '+' | '-' ) ^ add_exp )? ;
	[GrammarRule("add_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> add_exp()
	{
		EnterRule_add_exp();
		EnterRule("add_exp", 24);
		TraceIn("add_exp", 24);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set68 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> multiply_exp67 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> add_exp69 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set68_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "add_exp");
		DebugLocation(100, 48);
		try
		{
			// DataTemplate.g:100:11: ( multiply_exp ( ( '+' | '-' ) ^ add_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:100:13: multiply_exp ( ( '+' | '-' ) ^ add_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(100, 13);
			PushFollow(Follow._multiply_exp_in_add_exp595);
			multiply_exp67=multiply_exp();
			PopFollow();

			adaptor.AddChild(root_0, multiply_exp67.Tree);
			DebugLocation(100, 25);
			// DataTemplate.g:100:25: ( ( '+' | '-' ) ^ add_exp )?
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			int LA22_1 = input.LA(1);

			if (((LA22_1>=31 && LA22_1<=32)))
			{
				alt22 = 1;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:100:26: ( '+' | '-' ) ^ add_exp
				{
				DebugLocation(100, 35);

				set68=(IToken)input.LT(1);
				set68=(IToken)input.LT(1);
				if ((input.LA(1)>=31 && input.LA(1)<=32))
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set68), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(100, 40);
				PushFollow(Follow._add_exp_in_add_exp607);
				add_exp69=add_exp();
				PopFollow();

				adaptor.AddChild(root_0, add_exp69.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("add_exp", 24);
			LeaveRule("add_exp", 24);
			LeaveRule_add_exp();
		}
		DebugLocation(100, 48);
		} finally { DebugExitRule(GrammarFileName, "add_exp"); }
		return retval;

	}
	// $ANTLR end "add_exp"

	partial void EnterRule_multiply_exp();
	partial void LeaveRule_multiply_exp();
	// $ANTLR start "multiply_exp"
	// DataTemplate.g:101:1: multiply_exp : unary_exp ( ( '*' | '/' | '%' ) ^ multiply_exp )? ;
	[GrammarRule("multiply_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> multiply_exp()
	{
		EnterRule_multiply_exp();
		EnterRule("multiply_exp", 25);
		TraceIn("multiply_exp", 25);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set71 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unary_exp70 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multiply_exp72 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set71_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multiply_exp");
		DebugLocation(101, 57);
		try
		{
			// DataTemplate.g:101:14: ( unary_exp ( ( '*' | '/' | '%' ) ^ multiply_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:101:16: unary_exp ( ( '*' | '/' | '%' ) ^ multiply_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(101, 16);
			PushFollow(Follow._unary_exp_in_multiply_exp616);
			unary_exp70=unary_exp();
			PopFollow();

			adaptor.AddChild(root_0, unary_exp70.Tree);
			DebugLocation(101, 26);
			// DataTemplate.g:101:26: ( ( '*' | '/' | '%' ) ^ multiply_exp )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==25||LA23_1==30||LA23_1==33))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:101:27: ( '*' | '/' | '%' ) ^ multiply_exp
				{
				DebugLocation(101, 40);

				set71=(IToken)input.LT(1);
				set71=(IToken)input.LT(1);
				if (input.LA(1)==25||input.LA(1)==30||input.LA(1)==33)
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set71), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(101, 44);
				PushFollow(Follow._multiply_exp_in_multiply_exp630);
				multiply_exp72=multiply_exp();
				PopFollow();

				adaptor.AddChild(root_0, multiply_exp72.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiply_exp", 25);
			LeaveRule("multiply_exp", 25);
			LeaveRule_multiply_exp();
		}
		DebugLocation(101, 57);
		} finally { DebugExitRule(GrammarFileName, "multiply_exp"); }
		return retval;

	}
	// $ANTLR end "multiply_exp"

	partial void EnterRule_unary_exp();
	partial void LeaveRule_unary_exp();
	// $ANTLR start "unary_exp"
	// DataTemplate.g:102:1: unary_exp : ( literal | ( '~' | '-' | '!' ) ^ unary_exp );
	[GrammarRule("unary_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> unary_exp()
	{
		EnterRule_unary_exp();
		EnterRule("unary_exp", 26);
		TraceIn("unary_exp", 26);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set74 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> literal73 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unary_exp75 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set74_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unary_exp");
		DebugLocation(102, 30);
		try
		{
			// DataTemplate.g:102:12: ( literal | ( '~' | '-' | '!' ) ^ unary_exp )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1==NUMBER||LA24_1==28))
			{
				alt24 = 1;
			}
			else if ((LA24_1==23||LA24_1==32||LA24_1==55))
			{
				alt24 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 24, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:102:14: literal
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(102, 14);
				PushFollow(Follow._literal_in_unary_exp640);
				literal73=literal();
				PopFollow();

				adaptor.AddChild(root_0, literal73.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// DataTemplate.g:103:7: ( '~' | '-' | '!' ) ^ unary_exp
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(103, 20);

				set74=(IToken)input.LT(1);
				set74=(IToken)input.LT(1);
				if (input.LA(1)==23||input.LA(1)==32||input.LA(1)==55)
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set74), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(103, 22);
				PushFollow(Follow._unary_exp_in_unary_exp657);
				unary_exp75=unary_exp();
				PopFollow();

				adaptor.AddChild(root_0, unary_exp75.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unary_exp", 26);
			LeaveRule("unary_exp", 26);
			LeaveRule_unary_exp();
		}
		DebugLocation(103, 30);
		} finally { DebugExitRule(GrammarFileName, "unary_exp"); }
		return retval;

	}
	// $ANTLR end "unary_exp"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// DataTemplate.g:104:1: literal : ( NUMBER -> ^( LITERAL NUMBER ) | '(' cond_exp ')' -> cond_exp );
	[GrammarRule("literal")]
	private AstParserRuleReturnScope<CommonTree, IToken> literal()
	{
		EnterRule_literal();
		EnterRule("literal", 27);
		TraceIn("literal", 27);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NUMBER76 = default(IToken);
		IToken char_literal77 = default(IToken);
		IToken char_literal79 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> cond_exp78 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NUMBER76_tree = default(CommonTree);
		CommonTree char_literal77_tree = default(CommonTree);
		CommonTree char_literal79_tree = default(CommonTree);
		RewriteRuleITokenStream stream_28=new RewriteRuleITokenStream(adaptor,"token 28");
		RewriteRuleITokenStream stream_29=new RewriteRuleITokenStream(adaptor,"token 29");
		RewriteRuleITokenStream stream_NUMBER=new RewriteRuleITokenStream(adaptor,"token NUMBER");
		RewriteRuleSubtreeStream stream_cond_exp=new RewriteRuleSubtreeStream(adaptor,"rule cond_exp");
		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(104, 34);
		try
		{
			// DataTemplate.g:104:11: ( NUMBER -> ^( LITERAL NUMBER ) | '(' cond_exp ')' -> cond_exp )
			int alt25=2;
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1==NUMBER))
			{
				alt25 = 1;
			}
			else if ((LA25_1==28))
			{
				alt25 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 25, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:104:13: NUMBER
				{
				DebugLocation(104, 13);
				NUMBER76=(IToken)Match(input,NUMBER,Follow._NUMBER_in_literal666);  
				stream_NUMBER.Add(NUMBER76);



				{
				// AST REWRITE
				// elements: NUMBER
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 104:20: -> ^( LITERAL NUMBER )
				{
					DebugLocation(104, 23);
					// DataTemplate.g:104:23: ^( LITERAL NUMBER )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(104, 25);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LITERAL, "LITERAL"), root_1);

					DebugLocation(104, 33);
					adaptor.AddChild(root_1, stream_NUMBER.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// DataTemplate.g:105:7: '(' cond_exp ')'
				{
				DebugLocation(105, 7);
				char_literal77=(IToken)Match(input,28,Follow._28_in_literal682);  
				stream_28.Add(char_literal77);

				DebugLocation(105, 11);
				PushFollow(Follow._cond_exp_in_literal684);
				cond_exp78=cond_exp();
				PopFollow();

				stream_cond_exp.Add(cond_exp78.Tree);
				DebugLocation(105, 20);
				char_literal79=(IToken)Match(input,29,Follow._29_in_literal686);  
				stream_29.Add(char_literal79);



				{
				// AST REWRITE
				// elements: cond_exp
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 105:24: -> cond_exp
				{
					DebugLocation(105, 27);
					adaptor.AddChild(root_0, stream_cond_exp.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literal", 27);
			LeaveRule("literal", 27);
			LeaveRule_literal();
		}
		DebugLocation(105, 34);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return retval;

	}
	// $ANTLR end "literal"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _data_temp_line_in_data_temp119 = new BitSet(new ulong[]{0x1F000000000002UL});
		public static readonly BitSet _data_line_decl_in_data_temp_line138 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _35_in_data_temp_line140 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _byte_decl_in_data_line_decl149 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _word_decl_in_data_line_decl157 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dword_decl_in_data_line_decl165 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _qword_decl_in_data_line_decl173 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_decl_in_data_line_decl181 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _48_in_byte_decl190 = new BitSet(new ulong[]{0x100010000002UL});
		public static readonly BitSet _func_decl_in_byte_decl193 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _arr_decl_in_byte_decl196 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _52_in_word_decl205 = new BitSet(new ulong[]{0x100010000002UL});
		public static readonly BitSet _func_decl_in_word_decl208 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _arr_decl_in_word_decl211 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _49_in_dword_decl220 = new BitSet(new ulong[]{0x100010000002UL});
		public static readonly BitSet _func_decl_in_dword_decl223 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _arr_decl_in_dword_decl226 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _50_in_qword_decl235 = new BitSet(new ulong[]{0x100010000002UL});
		public static readonly BitSet _func_decl_in_qword_decl238 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _arr_decl_in_qword_decl241 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _51_in_string_decl250 = new BitSet(new ulong[]{0x100010000002UL});
		public static readonly BitSet _string_fdecl_in_string_decl253 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _arr_decl_in_string_decl256 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _28_in_string_fdecl265 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _expression_in_string_fdecl267 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _29_in_string_fdecl269 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _28_in_func_decl285 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _format_type_in_func_decl287 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _29_in_func_decl289 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _44_in_arr_decl306 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _expression_in_arr_decl308 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _46_in_arr_decl310 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _format_arg_in_format_type327 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _45_in_format_arg344 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _FORMAT_ARG_in_format_arg347 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _45_in_format_arg349 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cond_exp_in_expression379 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bool_or_exp_in_cond_exp396 = new BitSet(new ulong[]{0x80000000002UL});
		public static readonly BitSet _43_in_cond_exp399 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _cond_exp_in_cond_exp406 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_cond_exp408 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _cond_exp_in_cond_exp411 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bool_and_exp_in_bool_or_exp421 = new BitSet(new ulong[]{0x40000000000002UL});
		public static readonly BitSet _54_in_bool_or_exp423 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _bool_or_exp_in_bool_or_exp430 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _or_exp_in_bool_and_exp439 = new BitSet(new ulong[]{0x4000002UL});
		public static readonly BitSet _26_in_bool_and_exp443 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _bool_and_exp_in_bool_and_exp450 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xor_exp_in_or_exp461 = new BitSet(new ulong[]{0x20000000000002UL});
		public static readonly BitSet _53_in_or_exp465 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _or_exp_in_or_exp472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _and_exp_in_xor_exp483 = new BitSet(new ulong[]{0x800000000002UL});
		public static readonly BitSet _47_in_xor_exp487 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _xor_exp_in_xor_exp494 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equals_exp_in_and_exp505 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _27_in_and_exp508 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _and_exp_in_and_exp515 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _compare_exp_in_equals_exp525 = new BitSet(new ulong[]{0x8001000002UL});
		public static readonly BitSet _set_in_equals_exp528 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _equals_exp_in_equals_exp537 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shift_exp_in_compare_exp547 = new BitSet(new ulong[]{0x35000000002UL});
		public static readonly BitSet _set_in_compare_exp550 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _compare_exp_in_compare_exp561 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _add_exp_in_shift_exp571 = new BitSet(new ulong[]{0x42000000002UL});
		public static readonly BitSet _set_in_shift_exp575 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _shift_exp_in_shift_exp584 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multiply_exp_in_add_exp595 = new BitSet(new ulong[]{0x180000002UL});
		public static readonly BitSet _set_in_add_exp597 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _add_exp_in_add_exp607 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unary_exp_in_multiply_exp616 = new BitSet(new ulong[]{0x242000002UL});
		public static readonly BitSet _set_in_multiply_exp619 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _multiply_exp_in_multiply_exp630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literal_in_unary_exp640 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_unary_exp648 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _unary_exp_in_unary_exp657 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_literal666 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _28_in_literal682 = new BitSet(new ulong[]{0x80000110820000UL});
		public static readonly BitSet _cond_exp_in_literal684 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _29_in_literal686 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace GBRead.Base
