//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 DataTemplate.g 2012-11-06 21:04:36

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

#pragma warning disable 3021

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace GBRead.Base
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class DataTemplateParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARG", "ARRLEN", "BIN_DIGIT", "BIN_NUMBER", "COMMENT", "EXPRESSION", "FIXSTRING", "HEX_DIGIT", "HEX_NUMBER", "INT", "LITERAL", "NUMBER", "OCT_DIGIT", "OCT_NUMBER", "ROOT", "VARSTRING", "WS", "'!'", "'!='", "'%'", "'&&'", "'&'", "'('", "')'", "'*'", "'+'", "'-'", "'/'", "':'", "';'", "'<'", "'<<'", "'<='", "'=='", "'>'", "'>='", "'>>'", "'?'", "'['", "']'", "'^'", "'byte'", "'dword'", "'qword'", "'string'", "'word'", "'|'", "'||'", "'~'"
	};
	public const int EOF=-1;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int T__29=29;
	public const int T__30=30;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int ARG=4;
	public const int ARRLEN=5;
	public const int BIN_DIGIT=6;
	public const int BIN_NUMBER=7;
	public const int COMMENT=8;
	public const int EXPRESSION=9;
	public const int FIXSTRING=10;
	public const int HEX_DIGIT=11;
	public const int HEX_NUMBER=12;
	public const int INT=13;
	public const int LITERAL=14;
	public const int NUMBER=15;
	public const int OCT_DIGIT=16;
	public const int OCT_NUMBER=17;
	public const int ROOT=18;
	public const int VARSTRING=19;
	public const int WS=20;

	public DataTemplateParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public DataTemplateParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return DataTemplateParser.tokenNames; } }
	public override string GrammarFileName { get { return "DataTemplate.g"; } }


	private List<ErrInfo> Errors = new List<ErrInfo>();

	public override void DisplayRecognitionError(string[] tokenNames, RecognitionException e)
	{
		string errHeader = GetErrorHeader(e);
		string errMSG = GetErrorMessage(e, tokenNames);
		Errors.Add(new ErrInfo() {errText = errMSG, error = e});
	}

	public List<ErrInfo> GetErrors()
	{
		return Errors;
	}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_data_temp();
	partial void LeaveRule_data_temp();

	// $ANTLR start "data_temp"
	// DataTemplate.g:61:8: public data_temp : ( data_temp_line )* -> ^( ROOT ( data_temp_line )* ) ;
	[GrammarRule("data_temp")]
	public AstParserRuleReturnScope<CommonTree, IToken> data_temp()
	{
		EnterRule_data_temp();
		EnterRule("data_temp", 1);
		TraceIn("data_temp", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> data_temp_line1 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_data_temp_line=new RewriteRuleSubtreeStream(adaptor,"rule data_temp_line");
		try { DebugEnterRule(GrammarFileName, "data_temp");
		DebugLocation(61, 62);
		try
		{
			// DataTemplate.g:61:17: ( ( data_temp_line )* -> ^( ROOT ( data_temp_line )* ) )
			DebugEnterAlt(1);
			// DataTemplate.g:61:19: ( data_temp_line )*
			{
			DebugLocation(61, 19);
			// DataTemplate.g:61:19: ( data_temp_line )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>=45 && LA1_0<=49)))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// DataTemplate.g:61:20: data_temp_line
					{
					DebugLocation(61, 20);
					PushFollow(Follow._data_temp_line_in_data_temp115);
					data_temp_line1=data_temp_line();
					PopFollow();

					stream_data_temp_line.Add(data_temp_line1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: data_temp_line
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 61:37: -> ^( ROOT ( data_temp_line )* )
			{
				DebugLocation(61, 40);
				// DataTemplate.g:61:40: ^( ROOT ( data_temp_line )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(61, 42);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ROOT, "ROOT"), root_1);

				DebugLocation(61, 47);
				// DataTemplate.g:61:47: ( data_temp_line )*
				while ( stream_data_temp_line.HasNext )
				{
					DebugLocation(61, 47);
					adaptor.AddChild(root_1, stream_data_temp_line.NextTree());

				}
				stream_data_temp_line.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("data_temp", 1);
			LeaveRule("data_temp", 1);
			LeaveRule_data_temp();
		}
		DebugLocation(61, 62);
		} finally { DebugExitRule(GrammarFileName, "data_temp"); }
		return retval;

	}
	// $ANTLR end "data_temp"

	partial void EnterRule_data_temp_line();
	partial void LeaveRule_data_temp_line();

	// $ANTLR start "data_temp_line"
	// DataTemplate.g:63:1: data_temp_line : data_line_decl ';' !;
	[GrammarRule("data_temp_line")]
	private AstParserRuleReturnScope<CommonTree, IToken> data_temp_line()
	{
		EnterRule_data_temp_line();
		EnterRule("data_temp_line", 2);
		TraceIn("data_temp_line", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal3 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> data_line_decl2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal3_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "data_temp_line");
		DebugLocation(63, 36);
		try
		{
			// DataTemplate.g:63:16: ( data_line_decl ';' !)
			DebugEnterAlt(1);
			// DataTemplate.g:63:18: data_line_decl ';' !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(63, 18);
			PushFollow(Follow._data_line_decl_in_data_temp_line134);
			data_line_decl2=data_line_decl();
			PopFollow();

			adaptor.AddChild(root_0, data_line_decl2.Tree);
			DebugLocation(63, 36);
			char_literal3=(IToken)Match(input,33,Follow._33_in_data_temp_line136); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("data_temp_line", 2);
			LeaveRule("data_temp_line", 2);
			LeaveRule_data_temp_line();
		}
		DebugLocation(63, 36);
		} finally { DebugExitRule(GrammarFileName, "data_temp_line"); }
		return retval;

	}
	// $ANTLR end "data_temp_line"

	partial void EnterRule_data_line_decl();
	partial void LeaveRule_data_line_decl();

	// $ANTLR start "data_line_decl"
	// DataTemplate.g:65:1: data_line_decl : ( byte_decl | word_decl | dword_decl | qword_decl | string_decl );
	[GrammarRule("data_line_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> data_line_decl()
	{
		EnterRule_data_line_decl();
		EnterRule("data_line_decl", 3);
		TraceIn("data_line_decl", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> byte_decl4 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> word_decl5 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dword_decl6 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> qword_decl7 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> string_decl8 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "data_line_decl");
		DebugLocation(65, 17);
		try
		{
			// DataTemplate.g:65:16: ( byte_decl | word_decl | dword_decl | qword_decl | string_decl )
			int alt2=5;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case 45:
				{
				alt2 = 1;
				}
				break;
			case 49:
				{
				alt2 = 2;
				}
				break;
			case 46:
				{
				alt2 = 3;
				}
				break;
			case 47:
				{
				alt2 = 4;
				}
				break;
			case 48:
				{
				alt2 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:65:18: byte_decl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(65, 18);
				PushFollow(Follow._byte_decl_in_data_line_decl145);
				byte_decl4=byte_decl();
				PopFollow();

				adaptor.AddChild(root_0, byte_decl4.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// DataTemplate.g:66:7: word_decl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(66, 7);
				PushFollow(Follow._word_decl_in_data_line_decl153);
				word_decl5=word_decl();
				PopFollow();

				adaptor.AddChild(root_0, word_decl5.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// DataTemplate.g:67:7: dword_decl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(67, 7);
				PushFollow(Follow._dword_decl_in_data_line_decl161);
				dword_decl6=dword_decl();
				PopFollow();

				adaptor.AddChild(root_0, dword_decl6.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// DataTemplate.g:68:7: qword_decl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(68, 7);
				PushFollow(Follow._qword_decl_in_data_line_decl169);
				qword_decl7=qword_decl();
				PopFollow();

				adaptor.AddChild(root_0, qword_decl7.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// DataTemplate.g:69:7: string_decl
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(69, 7);
				PushFollow(Follow._string_decl_in_data_line_decl177);
				string_decl8=string_decl();
				PopFollow();

				adaptor.AddChild(root_0, string_decl8.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("data_line_decl", 3);
			LeaveRule("data_line_decl", 3);
			LeaveRule_data_line_decl();
		}
		DebugLocation(69, 17);
		} finally { DebugExitRule(GrammarFileName, "data_line_decl"); }
		return retval;

	}
	// $ANTLR end "data_line_decl"

	partial void EnterRule_byte_decl();
	partial void LeaveRule_byte_decl();

	// $ANTLR start "byte_decl"
	// DataTemplate.g:71:1: byte_decl : 'byte' ^ ( func_decl )? ( arr_decl )? ;
	[GrammarRule("byte_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> byte_decl()
	{
		EnterRule_byte_decl();
		EnterRule("byte_decl", 4);
		TraceIn("byte_decl", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal9 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_decl10 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arr_decl11 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal9_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "byte_decl");
		DebugLocation(71, 41);
		try
		{
			// DataTemplate.g:71:12: ( 'byte' ^ ( func_decl )? ( arr_decl )? )
			DebugEnterAlt(1);
			// DataTemplate.g:71:14: 'byte' ^ ( func_decl )? ( arr_decl )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(71, 20);
			string_literal9=(IToken)Match(input,45,Follow._45_in_byte_decl186); 
			string_literal9_tree = (CommonTree)adaptor.Create(string_literal9);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal9_tree, root_0);
			DebugLocation(71, 22);
			// DataTemplate.g:71:22: ( func_decl )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==26))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:71:22: func_decl
				{
				DebugLocation(71, 22);
				PushFollow(Follow._func_decl_in_byte_decl189);
				func_decl10=func_decl();
				PopFollow();

				adaptor.AddChild(root_0, func_decl10.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(71, 33);
			// DataTemplate.g:71:33: ( arr_decl )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==42))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:71:33: arr_decl
				{
				DebugLocation(71, 33);
				PushFollow(Follow._arr_decl_in_byte_decl192);
				arr_decl11=arr_decl();
				PopFollow();

				adaptor.AddChild(root_0, arr_decl11.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("byte_decl", 4);
			LeaveRule("byte_decl", 4);
			LeaveRule_byte_decl();
		}
		DebugLocation(71, 41);
		} finally { DebugExitRule(GrammarFileName, "byte_decl"); }
		return retval;

	}
	// $ANTLR end "byte_decl"

	partial void EnterRule_word_decl();
	partial void LeaveRule_word_decl();

	// $ANTLR start "word_decl"
	// DataTemplate.g:72:1: word_decl : 'word' ^ ( func_decl )? ( arr_decl )? ;
	[GrammarRule("word_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> word_decl()
	{
		EnterRule_word_decl();
		EnterRule("word_decl", 5);
		TraceIn("word_decl", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal12 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_decl13 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arr_decl14 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal12_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "word_decl");
		DebugLocation(72, 41);
		try
		{
			// DataTemplate.g:72:12: ( 'word' ^ ( func_decl )? ( arr_decl )? )
			DebugEnterAlt(1);
			// DataTemplate.g:72:14: 'word' ^ ( func_decl )? ( arr_decl )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(72, 20);
			string_literal12=(IToken)Match(input,49,Follow._49_in_word_decl201); 
			string_literal12_tree = (CommonTree)adaptor.Create(string_literal12);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal12_tree, root_0);
			DebugLocation(72, 22);
			// DataTemplate.g:72:22: ( func_decl )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==26))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:72:22: func_decl
				{
				DebugLocation(72, 22);
				PushFollow(Follow._func_decl_in_word_decl204);
				func_decl13=func_decl();
				PopFollow();

				adaptor.AddChild(root_0, func_decl13.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(72, 33);
			// DataTemplate.g:72:33: ( arr_decl )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==42))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:72:33: arr_decl
				{
				DebugLocation(72, 33);
				PushFollow(Follow._arr_decl_in_word_decl207);
				arr_decl14=arr_decl();
				PopFollow();

				adaptor.AddChild(root_0, arr_decl14.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("word_decl", 5);
			LeaveRule("word_decl", 5);
			LeaveRule_word_decl();
		}
		DebugLocation(72, 41);
		} finally { DebugExitRule(GrammarFileName, "word_decl"); }
		return retval;

	}
	// $ANTLR end "word_decl"

	partial void EnterRule_dword_decl();
	partial void LeaveRule_dword_decl();

	// $ANTLR start "dword_decl"
	// DataTemplate.g:73:1: dword_decl : 'dword' ^ ( func_decl )? ( arr_decl )? ;
	[GrammarRule("dword_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> dword_decl()
	{
		EnterRule_dword_decl();
		EnterRule("dword_decl", 6);
		TraceIn("dword_decl", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal15 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_decl16 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arr_decl17 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal15_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "dword_decl");
		DebugLocation(73, 43);
		try
		{
			// DataTemplate.g:73:13: ( 'dword' ^ ( func_decl )? ( arr_decl )? )
			DebugEnterAlt(1);
			// DataTemplate.g:73:15: 'dword' ^ ( func_decl )? ( arr_decl )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(73, 22);
			string_literal15=(IToken)Match(input,46,Follow._46_in_dword_decl216); 
			string_literal15_tree = (CommonTree)adaptor.Create(string_literal15);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal15_tree, root_0);
			DebugLocation(73, 24);
			// DataTemplate.g:73:24: ( func_decl )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==26))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:73:24: func_decl
				{
				DebugLocation(73, 24);
				PushFollow(Follow._func_decl_in_dword_decl219);
				func_decl16=func_decl();
				PopFollow();

				adaptor.AddChild(root_0, func_decl16.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(73, 35);
			// DataTemplate.g:73:35: ( arr_decl )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==42))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:73:35: arr_decl
				{
				DebugLocation(73, 35);
				PushFollow(Follow._arr_decl_in_dword_decl222);
				arr_decl17=arr_decl();
				PopFollow();

				adaptor.AddChild(root_0, arr_decl17.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dword_decl", 6);
			LeaveRule("dword_decl", 6);
			LeaveRule_dword_decl();
		}
		DebugLocation(73, 43);
		} finally { DebugExitRule(GrammarFileName, "dword_decl"); }
		return retval;

	}
	// $ANTLR end "dword_decl"

	partial void EnterRule_qword_decl();
	partial void LeaveRule_qword_decl();

	// $ANTLR start "qword_decl"
	// DataTemplate.g:74:1: qword_decl : 'qword' ^ ( func_decl )? ( arr_decl )? ;
	[GrammarRule("qword_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> qword_decl()
	{
		EnterRule_qword_decl();
		EnterRule("qword_decl", 7);
		TraceIn("qword_decl", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal18 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_decl19 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arr_decl20 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal18_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "qword_decl");
		DebugLocation(74, 43);
		try
		{
			// DataTemplate.g:74:13: ( 'qword' ^ ( func_decl )? ( arr_decl )? )
			DebugEnterAlt(1);
			// DataTemplate.g:74:15: 'qword' ^ ( func_decl )? ( arr_decl )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(74, 22);
			string_literal18=(IToken)Match(input,47,Follow._47_in_qword_decl231); 
			string_literal18_tree = (CommonTree)adaptor.Create(string_literal18);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal18_tree, root_0);
			DebugLocation(74, 24);
			// DataTemplate.g:74:24: ( func_decl )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==26))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:74:24: func_decl
				{
				DebugLocation(74, 24);
				PushFollow(Follow._func_decl_in_qword_decl234);
				func_decl19=func_decl();
				PopFollow();

				adaptor.AddChild(root_0, func_decl19.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(74, 35);
			// DataTemplate.g:74:35: ( arr_decl )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==42))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:74:35: arr_decl
				{
				DebugLocation(74, 35);
				PushFollow(Follow._arr_decl_in_qword_decl237);
				arr_decl20=arr_decl();
				PopFollow();

				adaptor.AddChild(root_0, arr_decl20.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("qword_decl", 7);
			LeaveRule("qword_decl", 7);
			LeaveRule_qword_decl();
		}
		DebugLocation(74, 43);
		} finally { DebugExitRule(GrammarFileName, "qword_decl"); }
		return retval;

	}
	// $ANTLR end "qword_decl"

	partial void EnterRule_string_decl();
	partial void LeaveRule_string_decl();

	// $ANTLR start "string_decl"
	// DataTemplate.g:75:1: string_decl : 'string' ^ ( func_decl )? ( arr_decl )? ;
	[GrammarRule("string_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> string_decl()
	{
		EnterRule_string_decl();
		EnterRule("string_decl", 8);
		TraceIn("string_decl", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal21 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_decl22 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arr_decl23 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal21_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "string_decl");
		DebugLocation(75, 45);
		try
		{
			// DataTemplate.g:75:14: ( 'string' ^ ( func_decl )? ( arr_decl )? )
			DebugEnterAlt(1);
			// DataTemplate.g:75:16: 'string' ^ ( func_decl )? ( arr_decl )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(75, 24);
			string_literal21=(IToken)Match(input,48,Follow._48_in_string_decl246); 
			string_literal21_tree = (CommonTree)adaptor.Create(string_literal21);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal21_tree, root_0);
			DebugLocation(75, 26);
			// DataTemplate.g:75:26: ( func_decl )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==26))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:75:26: func_decl
				{
				DebugLocation(75, 26);
				PushFollow(Follow._func_decl_in_string_decl249);
				func_decl22=func_decl();
				PopFollow();

				adaptor.AddChild(root_0, func_decl22.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(75, 37);
			// DataTemplate.g:75:37: ( arr_decl )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==42))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:75:37: arr_decl
				{
				DebugLocation(75, 37);
				PushFollow(Follow._arr_decl_in_string_decl252);
				arr_decl23=arr_decl();
				PopFollow();

				adaptor.AddChild(root_0, arr_decl23.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("string_decl", 8);
			LeaveRule("string_decl", 8);
			LeaveRule_string_decl();
		}
		DebugLocation(75, 45);
		} finally { DebugExitRule(GrammarFileName, "string_decl"); }
		return retval;

	}
	// $ANTLR end "string_decl"

	partial void EnterRule_func_decl();
	partial void LeaveRule_func_decl();

	// $ANTLR start "func_decl"
	// DataTemplate.g:77:1: func_decl : '(' expression ')' -> ^( ARG expression ) ;
	[GrammarRule("func_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> func_decl()
	{
		EnterRule_func_decl();
		EnterRule("func_decl", 9);
		TraceIn("func_decl", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal24 = default(IToken);
		IToken char_literal26 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression25 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal24_tree = default(CommonTree);
		CommonTree char_literal26_tree = default(CommonTree);
		RewriteRuleITokenStream stream_26=new RewriteRuleITokenStream(adaptor,"token 26");
		RewriteRuleITokenStream stream_27=new RewriteRuleITokenStream(adaptor,"token 27");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "func_decl");
		DebugLocation(77, 52);
		try
		{
			// DataTemplate.g:77:12: ( '(' expression ')' -> ^( ARG expression ) )
			DebugEnterAlt(1);
			// DataTemplate.g:77:14: '(' expression ')'
			{
			DebugLocation(77, 14);
			char_literal24=(IToken)Match(input,26,Follow._26_in_func_decl262);  
			stream_26.Add(char_literal24);

			DebugLocation(77, 18);
			PushFollow(Follow._expression_in_func_decl264);
			expression25=expression();
			PopFollow();

			stream_expression.Add(expression25.Tree);
			DebugLocation(77, 29);
			char_literal26=(IToken)Match(input,27,Follow._27_in_func_decl266);  
			stream_27.Add(char_literal26);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 77:33: -> ^( ARG expression )
			{
				DebugLocation(77, 36);
				// DataTemplate.g:77:36: ^( ARG expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(77, 38);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(77, 42);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("func_decl", 9);
			LeaveRule("func_decl", 9);
			LeaveRule_func_decl();
		}
		DebugLocation(77, 52);
		} finally { DebugExitRule(GrammarFileName, "func_decl"); }
		return retval;

	}
	// $ANTLR end "func_decl"

	partial void EnterRule_arr_decl();
	partial void LeaveRule_arr_decl();

	// $ANTLR start "arr_decl"
	// DataTemplate.g:78:1: arr_decl : '[' expression ']' -> ^( ARRLEN expression ) ;
	[GrammarRule("arr_decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> arr_decl()
	{
		EnterRule_arr_decl();
		EnterRule("arr_decl", 10);
		TraceIn("arr_decl", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal27 = default(IToken);
		IToken char_literal29 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression28 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal27_tree = default(CommonTree);
		CommonTree char_literal29_tree = default(CommonTree);
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "arr_decl");
		DebugLocation(78, 54);
		try
		{
			// DataTemplate.g:78:11: ( '[' expression ']' -> ^( ARRLEN expression ) )
			DebugEnterAlt(1);
			// DataTemplate.g:78:13: '[' expression ']'
			{
			DebugLocation(78, 13);
			char_literal27=(IToken)Match(input,42,Follow._42_in_arr_decl282);  
			stream_42.Add(char_literal27);

			DebugLocation(78, 17);
			PushFollow(Follow._expression_in_arr_decl284);
			expression28=expression();
			PopFollow();

			stream_expression.Add(expression28.Tree);
			DebugLocation(78, 28);
			char_literal29=(IToken)Match(input,43,Follow._43_in_arr_decl286);  
			stream_43.Add(char_literal29);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 78:32: -> ^( ARRLEN expression )
			{
				DebugLocation(78, 35);
				// DataTemplate.g:78:35: ^( ARRLEN expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(78, 37);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARRLEN, "ARRLEN"), root_1);

				DebugLocation(78, 44);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arr_decl", 10);
			LeaveRule("arr_decl", 10);
			LeaveRule_arr_decl();
		}
		DebugLocation(78, 54);
		} finally { DebugExitRule(GrammarFileName, "arr_decl"); }
		return retval;

	}
	// $ANTLR end "arr_decl"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// DataTemplate.g:80:1: expression : cond_exp -> ^( EXPRESSION cond_exp ) ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 11);
		TraceIn("expression", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> cond_exp30 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_cond_exp=new RewriteRuleSubtreeStream(adaptor,"rule cond_exp");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(80, 48);
		try
		{
			// DataTemplate.g:80:13: ( cond_exp -> ^( EXPRESSION cond_exp ) )
			DebugEnterAlt(1);
			// DataTemplate.g:80:15: cond_exp
			{
			DebugLocation(80, 15);
			PushFollow(Follow._cond_exp_in_expression303);
			cond_exp30=cond_exp();
			PopFollow();

			stream_cond_exp.Add(cond_exp30.Tree);


			{
			// AST REWRITE
			// elements: cond_exp
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 80:24: -> ^( EXPRESSION cond_exp )
			{
				DebugLocation(80, 27);
				// DataTemplate.g:80:27: ^( EXPRESSION cond_exp )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(80, 29);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXPRESSION, "EXPRESSION"), root_1);

				DebugLocation(80, 40);
				adaptor.AddChild(root_1, stream_cond_exp.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 11);
			LeaveRule("expression", 11);
			LeaveRule_expression();
		}
		DebugLocation(80, 48);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_cond_exp();
	partial void LeaveRule_cond_exp();

	// $ANTLR start "cond_exp"
	// DataTemplate.g:82:1: cond_exp : bool_or_exp ( '?' ^ cond_exp ':' ! cond_exp )? ;
	[GrammarRule("cond_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> cond_exp()
	{
		EnterRule_cond_exp();
		EnterRule("cond_exp", 12);
		TraceIn("cond_exp", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal32 = default(IToken);
		IToken char_literal34 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bool_or_exp31 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> cond_exp33 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> cond_exp35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal32_tree = default(CommonTree);
		CommonTree char_literal34_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "cond_exp");
		DebugLocation(82, 58);
		try
		{
			// DataTemplate.g:82:11: ( bool_or_exp ( '?' ^ cond_exp ':' ! cond_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:82:13: bool_or_exp ( '?' ^ cond_exp ':' ! cond_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(82, 13);
			PushFollow(Follow._bool_or_exp_in_cond_exp320);
			bool_or_exp31=bool_or_exp();
			PopFollow();

			adaptor.AddChild(root_0, bool_or_exp31.Tree);
			DebugLocation(82, 25);
			// DataTemplate.g:82:25: ( '?' ^ cond_exp ':' ! cond_exp )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==41))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:82:26: '?' ^ cond_exp ':' ! cond_exp
				{
				DebugLocation(82, 29);
				char_literal32=(IToken)Match(input,41,Follow._41_in_cond_exp323); 
				char_literal32_tree = (CommonTree)adaptor.Create(char_literal32);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal32_tree, root_0);
				DebugLocation(82, 35);
				PushFollow(Follow._cond_exp_in_cond_exp330);
				cond_exp33=cond_exp();
				PopFollow();

				adaptor.AddChild(root_0, cond_exp33.Tree);
				DebugLocation(82, 47);
				char_literal34=(IToken)Match(input,32,Follow._32_in_cond_exp332); 
				DebugLocation(82, 49);
				PushFollow(Follow._cond_exp_in_cond_exp335);
				cond_exp35=cond_exp();
				PopFollow();

				adaptor.AddChild(root_0, cond_exp35.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("cond_exp", 12);
			LeaveRule("cond_exp", 12);
			LeaveRule_cond_exp();
		}
		DebugLocation(82, 58);
		} finally { DebugExitRule(GrammarFileName, "cond_exp"); }
		return retval;

	}
	// $ANTLR end "cond_exp"

	partial void EnterRule_bool_or_exp();
	partial void LeaveRule_bool_or_exp();

	// $ANTLR start "bool_or_exp"
	// DataTemplate.g:83:1: bool_or_exp : bool_and_exp ( '||' ^ bool_or_exp )? ;
	[GrammarRule("bool_or_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> bool_or_exp()
	{
		EnterRule_bool_or_exp();
		EnterRule("bool_or_exp", 13);
		TraceIn("bool_or_exp", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal37 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bool_and_exp36 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bool_or_exp38 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal37_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bool_or_exp");
		DebugLocation(83, 51);
		try
		{
			// DataTemplate.g:83:14: ( bool_and_exp ( '||' ^ bool_or_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:83:16: bool_and_exp ( '||' ^ bool_or_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(83, 16);
			PushFollow(Follow._bool_and_exp_in_bool_or_exp345);
			bool_and_exp36=bool_and_exp();
			PopFollow();

			adaptor.AddChild(root_0, bool_and_exp36.Tree);
			DebugLocation(83, 28);
			// DataTemplate.g:83:28: ( '||' ^ bool_or_exp )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if ((LA14_0==51))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:83:29: '||' ^ bool_or_exp
				{
				DebugLocation(83, 33);
				string_literal37=(IToken)Match(input,51,Follow._51_in_bool_or_exp347); 
				string_literal37_tree = (CommonTree)adaptor.Create(string_literal37);
				root_0 = (CommonTree)adaptor.BecomeRoot(string_literal37_tree, root_0);
				DebugLocation(83, 39);
				PushFollow(Follow._bool_or_exp_in_bool_or_exp354);
				bool_or_exp38=bool_or_exp();
				PopFollow();

				adaptor.AddChild(root_0, bool_or_exp38.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bool_or_exp", 13);
			LeaveRule("bool_or_exp", 13);
			LeaveRule_bool_or_exp();
		}
		DebugLocation(83, 51);
		} finally { DebugExitRule(GrammarFileName, "bool_or_exp"); }
		return retval;

	}
	// $ANTLR end "bool_or_exp"

	partial void EnterRule_bool_and_exp();
	partial void LeaveRule_bool_and_exp();

	// $ANTLR start "bool_and_exp"
	// DataTemplate.g:84:1: bool_and_exp : or_exp ( '&&' ^ bool_and_exp )? ;
	[GrammarRule("bool_and_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> bool_and_exp()
	{
		EnterRule_bool_and_exp();
		EnterRule("bool_and_exp", 14);
		TraceIn("bool_and_exp", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal40 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> or_exp39 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bool_and_exp41 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal40_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bool_and_exp");
		DebugLocation(84, 48);
		try
		{
			// DataTemplate.g:84:14: ( or_exp ( '&&' ^ bool_and_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:84:16: or_exp ( '&&' ^ bool_and_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(84, 16);
			PushFollow(Follow._or_exp_in_bool_and_exp363);
			or_exp39=or_exp();
			PopFollow();

			adaptor.AddChild(root_0, or_exp39.Tree);
			DebugLocation(84, 24);
			// DataTemplate.g:84:24: ( '&&' ^ bool_and_exp )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==24))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:84:25: '&&' ^ bool_and_exp
				{
				DebugLocation(84, 29);
				string_literal40=(IToken)Match(input,24,Follow._24_in_bool_and_exp367); 
				string_literal40_tree = (CommonTree)adaptor.Create(string_literal40);
				root_0 = (CommonTree)adaptor.BecomeRoot(string_literal40_tree, root_0);
				DebugLocation(84, 35);
				PushFollow(Follow._bool_and_exp_in_bool_and_exp374);
				bool_and_exp41=bool_and_exp();
				PopFollow();

				adaptor.AddChild(root_0, bool_and_exp41.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bool_and_exp", 14);
			LeaveRule("bool_and_exp", 14);
			LeaveRule_bool_and_exp();
		}
		DebugLocation(84, 48);
		} finally { DebugExitRule(GrammarFileName, "bool_and_exp"); }
		return retval;

	}
	// $ANTLR end "bool_and_exp"

	partial void EnterRule_or_exp();
	partial void LeaveRule_or_exp();

	// $ANTLR start "or_exp"
	// DataTemplate.g:85:1: or_exp : xor_exp ( '|' ^ or_exp )? ;
	[GrammarRule("or_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> or_exp()
	{
		EnterRule_or_exp();
		EnterRule("or_exp", 15);
		TraceIn("or_exp", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal43 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> xor_exp42 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> or_exp44 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal43_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "or_exp");
		DebugLocation(85, 38);
		try
		{
			// DataTemplate.g:85:10: ( xor_exp ( '|' ^ or_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:85:12: xor_exp ( '|' ^ or_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(85, 12);
			PushFollow(Follow._xor_exp_in_or_exp385);
			xor_exp42=xor_exp();
			PopFollow();

			adaptor.AddChild(root_0, xor_exp42.Tree);
			DebugLocation(85, 21);
			// DataTemplate.g:85:21: ( '|' ^ or_exp )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==50))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:85:22: '|' ^ or_exp
				{
				DebugLocation(85, 25);
				char_literal43=(IToken)Match(input,50,Follow._50_in_or_exp389); 
				char_literal43_tree = (CommonTree)adaptor.Create(char_literal43);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal43_tree, root_0);
				DebugLocation(85, 31);
				PushFollow(Follow._or_exp_in_or_exp396);
				or_exp44=or_exp();
				PopFollow();

				adaptor.AddChild(root_0, or_exp44.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("or_exp", 15);
			LeaveRule("or_exp", 15);
			LeaveRule_or_exp();
		}
		DebugLocation(85, 38);
		} finally { DebugExitRule(GrammarFileName, "or_exp"); }
		return retval;

	}
	// $ANTLR end "or_exp"

	partial void EnterRule_xor_exp();
	partial void LeaveRule_xor_exp();

	// $ANTLR start "xor_exp"
	// DataTemplate.g:86:1: xor_exp : and_exp ( '^' ^ xor_exp )? ;
	[GrammarRule("xor_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> xor_exp()
	{
		EnterRule_xor_exp();
		EnterRule("xor_exp", 16);
		TraceIn("xor_exp", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal46 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> and_exp45 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> xor_exp47 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal46_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "xor_exp");
		DebugLocation(86, 40);
		try
		{
			// DataTemplate.g:86:11: ( and_exp ( '^' ^ xor_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:86:13: and_exp ( '^' ^ xor_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(86, 13);
			PushFollow(Follow._and_exp_in_xor_exp407);
			and_exp45=and_exp();
			PopFollow();

			adaptor.AddChild(root_0, and_exp45.Tree);
			DebugLocation(86, 22);
			// DataTemplate.g:86:22: ( '^' ^ xor_exp )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0==44))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:86:23: '^' ^ xor_exp
				{
				DebugLocation(86, 26);
				char_literal46=(IToken)Match(input,44,Follow._44_in_xor_exp411); 
				char_literal46_tree = (CommonTree)adaptor.Create(char_literal46);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal46_tree, root_0);
				DebugLocation(86, 32);
				PushFollow(Follow._xor_exp_in_xor_exp418);
				xor_exp47=xor_exp();
				PopFollow();

				adaptor.AddChild(root_0, xor_exp47.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xor_exp", 16);
			LeaveRule("xor_exp", 16);
			LeaveRule_xor_exp();
		}
		DebugLocation(86, 40);
		} finally { DebugExitRule(GrammarFileName, "xor_exp"); }
		return retval;

	}
	// $ANTLR end "xor_exp"

	partial void EnterRule_and_exp();
	partial void LeaveRule_and_exp();

	// $ANTLR start "and_exp"
	// DataTemplate.g:87:1: and_exp : equals_exp ( '&' ^ and_exp )? ;
	[GrammarRule("and_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> and_exp()
	{
		EnterRule_and_exp();
		EnterRule("and_exp", 17);
		TraceIn("and_exp", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal49 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> equals_exp48 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> and_exp50 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal49_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "and_exp");
		DebugLocation(87, 42);
		try
		{
			// DataTemplate.g:87:11: ( equals_exp ( '&' ^ and_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:87:13: equals_exp ( '&' ^ and_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(87, 13);
			PushFollow(Follow._equals_exp_in_and_exp429);
			equals_exp48=equals_exp();
			PopFollow();

			adaptor.AddChild(root_0, equals_exp48.Tree);
			DebugLocation(87, 24);
			// DataTemplate.g:87:24: ( '&' ^ and_exp )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==25))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:87:25: '&' ^ and_exp
				{
				DebugLocation(87, 28);
				char_literal49=(IToken)Match(input,25,Follow._25_in_and_exp432); 
				char_literal49_tree = (CommonTree)adaptor.Create(char_literal49);
				root_0 = (CommonTree)adaptor.BecomeRoot(char_literal49_tree, root_0);
				DebugLocation(87, 34);
				PushFollow(Follow._and_exp_in_and_exp439);
				and_exp50=and_exp();
				PopFollow();

				adaptor.AddChild(root_0, and_exp50.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("and_exp", 17);
			LeaveRule("and_exp", 17);
			LeaveRule_and_exp();
		}
		DebugLocation(87, 42);
		} finally { DebugExitRule(GrammarFileName, "and_exp"); }
		return retval;

	}
	// $ANTLR end "and_exp"

	partial void EnterRule_equals_exp();
	partial void LeaveRule_equals_exp();

	// $ANTLR start "equals_exp"
	// DataTemplate.g:88:1: equals_exp : compare_exp ( ( '==' | '!=' ) ^ equals_exp )? ;
	[GrammarRule("equals_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> equals_exp()
	{
		EnterRule_equals_exp();
		EnterRule("equals_exp", 18);
		TraceIn("equals_exp", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set52 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> compare_exp51 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> equals_exp53 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set52_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "equals_exp");
		DebugLocation(88, 54);
		try
		{
			// DataTemplate.g:88:13: ( compare_exp ( ( '==' | '!=' ) ^ equals_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:88:15: compare_exp ( ( '==' | '!=' ) ^ equals_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(88, 15);
			PushFollow(Follow._compare_exp_in_equals_exp449);
			compare_exp51=compare_exp();
			PopFollow();

			adaptor.AddChild(root_0, compare_exp51.Tree);
			DebugLocation(88, 27);
			// DataTemplate.g:88:27: ( ( '==' | '!=' ) ^ equals_exp )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==22||LA19_0==37))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:88:28: ( '==' | '!=' ) ^ equals_exp
				{
				DebugLocation(88, 39);

				set52=(IToken)input.LT(1);
				set52=(IToken)input.LT(1);
				if (input.LA(1)==22||input.LA(1)==37)
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set52), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(88, 43);
				PushFollow(Follow._equals_exp_in_equals_exp461);
				equals_exp53=equals_exp();
				PopFollow();

				adaptor.AddChild(root_0, equals_exp53.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equals_exp", 18);
			LeaveRule("equals_exp", 18);
			LeaveRule_equals_exp();
		}
		DebugLocation(88, 54);
		} finally { DebugExitRule(GrammarFileName, "equals_exp"); }
		return retval;

	}
	// $ANTLR end "equals_exp"

	partial void EnterRule_compare_exp();
	partial void LeaveRule_compare_exp();

	// $ANTLR start "compare_exp"
	// DataTemplate.g:89:1: compare_exp : shift_exp ( ( '<' | '>' | '<=' | '>=' ) ^ compare_exp )? ;
	[GrammarRule("compare_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> compare_exp()
	{
		EnterRule_compare_exp();
		EnterRule("compare_exp", 19);
		TraceIn("compare_exp", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set55 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> shift_exp54 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> compare_exp56 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set55_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "compare_exp");
		DebugLocation(89, 60);
		try
		{
			// DataTemplate.g:89:14: ( shift_exp ( ( '<' | '>' | '<=' | '>=' ) ^ compare_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:89:16: shift_exp ( ( '<' | '>' | '<=' | '>=' ) ^ compare_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(89, 16);
			PushFollow(Follow._shift_exp_in_compare_exp471);
			shift_exp54=shift_exp();
			PopFollow();

			adaptor.AddChild(root_0, shift_exp54.Tree);
			DebugLocation(89, 26);
			// DataTemplate.g:89:26: ( ( '<' | '>' | '<=' | '>=' ) ^ compare_exp )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==34||LA20_0==36||(LA20_0>=38 && LA20_0<=39)))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:89:27: ( '<' | '>' | '<=' | '>=' ) ^ compare_exp
				{
				DebugLocation(89, 46);

				set55=(IToken)input.LT(1);
				set55=(IToken)input.LT(1);
				if (input.LA(1)==34||input.LA(1)==36||(input.LA(1)>=38 && input.LA(1)<=39))
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set55), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(89, 48);
				PushFollow(Follow._compare_exp_in_compare_exp485);
				compare_exp56=compare_exp();
				PopFollow();

				adaptor.AddChild(root_0, compare_exp56.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compare_exp", 19);
			LeaveRule("compare_exp", 19);
			LeaveRule_compare_exp();
		}
		DebugLocation(89, 60);
		} finally { DebugExitRule(GrammarFileName, "compare_exp"); }
		return retval;

	}
	// $ANTLR end "compare_exp"

	partial void EnterRule_shift_exp();
	partial void LeaveRule_shift_exp();

	// $ANTLR start "shift_exp"
	// DataTemplate.g:90:1: shift_exp : add_exp ( ( '<<' | '>>' ) ^ shift_exp )? ;
	[GrammarRule("shift_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> shift_exp()
	{
		EnterRule_shift_exp();
		EnterRule("shift_exp", 20);
		TraceIn("shift_exp", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set58 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> add_exp57 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> shift_exp59 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set58_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "shift_exp");
		DebugLocation(90, 49);
		try
		{
			// DataTemplate.g:90:12: ( add_exp ( ( '<<' | '>>' ) ^ shift_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:90:14: add_exp ( ( '<<' | '>>' ) ^ shift_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(90, 14);
			PushFollow(Follow._add_exp_in_shift_exp495);
			add_exp57=add_exp();
			PopFollow();

			adaptor.AddChild(root_0, add_exp57.Tree);
			DebugLocation(90, 23);
			// DataTemplate.g:90:23: ( ( '<<' | '>>' ) ^ shift_exp )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_0 = input.LA(1);

			if ((LA21_0==35||LA21_0==40))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:90:24: ( '<<' | '>>' ) ^ shift_exp
				{
				DebugLocation(90, 35);

				set58=(IToken)input.LT(1);
				set58=(IToken)input.LT(1);
				if (input.LA(1)==35||input.LA(1)==40)
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set58), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(90, 39);
				PushFollow(Follow._shift_exp_in_shift_exp508);
				shift_exp59=shift_exp();
				PopFollow();

				adaptor.AddChild(root_0, shift_exp59.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shift_exp", 20);
			LeaveRule("shift_exp", 20);
			LeaveRule_shift_exp();
		}
		DebugLocation(90, 49);
		} finally { DebugExitRule(GrammarFileName, "shift_exp"); }
		return retval;

	}
	// $ANTLR end "shift_exp"

	partial void EnterRule_add_exp();
	partial void LeaveRule_add_exp();

	// $ANTLR start "add_exp"
	// DataTemplate.g:91:1: add_exp : multiply_exp ( ( '+' | '-' ) ^ add_exp )? ;
	[GrammarRule("add_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> add_exp()
	{
		EnterRule_add_exp();
		EnterRule("add_exp", 21);
		TraceIn("add_exp", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set61 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> multiply_exp60 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> add_exp62 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set61_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "add_exp");
		DebugLocation(91, 48);
		try
		{
			// DataTemplate.g:91:11: ( multiply_exp ( ( '+' | '-' ) ^ add_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:91:13: multiply_exp ( ( '+' | '-' ) ^ add_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(91, 13);
			PushFollow(Follow._multiply_exp_in_add_exp519);
			multiply_exp60=multiply_exp();
			PopFollow();

			adaptor.AddChild(root_0, multiply_exp60.Tree);
			DebugLocation(91, 25);
			// DataTemplate.g:91:25: ( ( '+' | '-' ) ^ add_exp )?
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			int LA22_0 = input.LA(1);

			if (((LA22_0>=29 && LA22_0<=30)))
			{
				alt22 = 1;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:91:26: ( '+' | '-' ) ^ add_exp
				{
				DebugLocation(91, 35);

				set61=(IToken)input.LT(1);
				set61=(IToken)input.LT(1);
				if ((input.LA(1)>=29 && input.LA(1)<=30))
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set61), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(91, 40);
				PushFollow(Follow._add_exp_in_add_exp531);
				add_exp62=add_exp();
				PopFollow();

				adaptor.AddChild(root_0, add_exp62.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("add_exp", 21);
			LeaveRule("add_exp", 21);
			LeaveRule_add_exp();
		}
		DebugLocation(91, 48);
		} finally { DebugExitRule(GrammarFileName, "add_exp"); }
		return retval;

	}
	// $ANTLR end "add_exp"

	partial void EnterRule_multiply_exp();
	partial void LeaveRule_multiply_exp();

	// $ANTLR start "multiply_exp"
	// DataTemplate.g:92:1: multiply_exp : unary_exp ( ( '*' | '/' | '%' ) ^ multiply_exp )? ;
	[GrammarRule("multiply_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> multiply_exp()
	{
		EnterRule_multiply_exp();
		EnterRule("multiply_exp", 22);
		TraceIn("multiply_exp", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set64 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unary_exp63 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multiply_exp65 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set64_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multiply_exp");
		DebugLocation(92, 57);
		try
		{
			// DataTemplate.g:92:14: ( unary_exp ( ( '*' | '/' | '%' ) ^ multiply_exp )? )
			DebugEnterAlt(1);
			// DataTemplate.g:92:16: unary_exp ( ( '*' | '/' | '%' ) ^ multiply_exp )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(92, 16);
			PushFollow(Follow._unary_exp_in_multiply_exp540);
			unary_exp63=unary_exp();
			PopFollow();

			adaptor.AddChild(root_0, unary_exp63.Tree);
			DebugLocation(92, 26);
			// DataTemplate.g:92:26: ( ( '*' | '/' | '%' ) ^ multiply_exp )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_0 = input.LA(1);

			if ((LA23_0==23||LA23_0==28||LA23_0==31))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:92:27: ( '*' | '/' | '%' ) ^ multiply_exp
				{
				DebugLocation(92, 40);

				set64=(IToken)input.LT(1);
				set64=(IToken)input.LT(1);
				if (input.LA(1)==23||input.LA(1)==28||input.LA(1)==31)
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set64), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(92, 44);
				PushFollow(Follow._multiply_exp_in_multiply_exp554);
				multiply_exp65=multiply_exp();
				PopFollow();

				adaptor.AddChild(root_0, multiply_exp65.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiply_exp", 22);
			LeaveRule("multiply_exp", 22);
			LeaveRule_multiply_exp();
		}
		DebugLocation(92, 57);
		} finally { DebugExitRule(GrammarFileName, "multiply_exp"); }
		return retval;

	}
	// $ANTLR end "multiply_exp"

	partial void EnterRule_unary_exp();
	partial void LeaveRule_unary_exp();

	// $ANTLR start "unary_exp"
	// DataTemplate.g:93:1: unary_exp : ( literal | ( '~' | '-' | '!' ) ^ unary_exp );
	[GrammarRule("unary_exp")]
	private AstParserRuleReturnScope<CommonTree, IToken> unary_exp()
	{
		EnterRule_unary_exp();
		EnterRule("unary_exp", 23);
		TraceIn("unary_exp", 23);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set67 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> literal66 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unary_exp68 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set67_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unary_exp");
		DebugLocation(93, 30);
		try
		{
			// DataTemplate.g:93:12: ( literal | ( '~' | '-' | '!' ) ^ unary_exp )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==NUMBER||LA24_0==26))
			{
				alt24 = 1;
			}
			else if ((LA24_0==21||LA24_0==30||LA24_0==52))
			{
				alt24 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:93:14: literal
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(93, 14);
				PushFollow(Follow._literal_in_unary_exp564);
				literal66=literal();
				PopFollow();

				adaptor.AddChild(root_0, literal66.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// DataTemplate.g:94:7: ( '~' | '-' | '!' ) ^ unary_exp
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(94, 20);

				set67=(IToken)input.LT(1);
				set67=(IToken)input.LT(1);
				if (input.LA(1)==21||input.LA(1)==30||input.LA(1)==52)
				{
					input.Consume();
					root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set67), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(94, 22);
				PushFollow(Follow._unary_exp_in_unary_exp581);
				unary_exp68=unary_exp();
				PopFollow();

				adaptor.AddChild(root_0, unary_exp68.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unary_exp", 23);
			LeaveRule("unary_exp", 23);
			LeaveRule_unary_exp();
		}
		DebugLocation(94, 30);
		} finally { DebugExitRule(GrammarFileName, "unary_exp"); }
		return retval;

	}
	// $ANTLR end "unary_exp"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();

	// $ANTLR start "literal"
	// DataTemplate.g:95:1: literal : ( NUMBER -> ^( LITERAL NUMBER ) | '(' cond_exp ')' -> cond_exp );
	[GrammarRule("literal")]
	private AstParserRuleReturnScope<CommonTree, IToken> literal()
	{
		EnterRule_literal();
		EnterRule("literal", 24);
		TraceIn("literal", 24);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NUMBER69 = default(IToken);
		IToken char_literal70 = default(IToken);
		IToken char_literal72 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> cond_exp71 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NUMBER69_tree = default(CommonTree);
		CommonTree char_literal70_tree = default(CommonTree);
		CommonTree char_literal72_tree = default(CommonTree);
		RewriteRuleITokenStream stream_26=new RewriteRuleITokenStream(adaptor,"token 26");
		RewriteRuleITokenStream stream_27=new RewriteRuleITokenStream(adaptor,"token 27");
		RewriteRuleITokenStream stream_NUMBER=new RewriteRuleITokenStream(adaptor,"token NUMBER");
		RewriteRuleSubtreeStream stream_cond_exp=new RewriteRuleSubtreeStream(adaptor,"rule cond_exp");
		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(95, 34);
		try
		{
			// DataTemplate.g:95:11: ( NUMBER -> ^( LITERAL NUMBER ) | '(' cond_exp ')' -> cond_exp )
			int alt25=2;
			try { DebugEnterDecision(25, false);
			int LA25_0 = input.LA(1);

			if ((LA25_0==NUMBER))
			{
				alt25 = 1;
			}
			else if ((LA25_0==26))
			{
				alt25 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// DataTemplate.g:95:13: NUMBER
				{
				DebugLocation(95, 13);
				NUMBER69=(IToken)Match(input,NUMBER,Follow._NUMBER_in_literal590);  
				stream_NUMBER.Add(NUMBER69);



				{
				// AST REWRITE
				// elements: NUMBER
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 95:20: -> ^( LITERAL NUMBER )
				{
					DebugLocation(95, 23);
					// DataTemplate.g:95:23: ^( LITERAL NUMBER )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(95, 25);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LITERAL, "LITERAL"), root_1);

					DebugLocation(95, 33);
					adaptor.AddChild(root_1, stream_NUMBER.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// DataTemplate.g:96:7: '(' cond_exp ')'
				{
				DebugLocation(96, 7);
				char_literal70=(IToken)Match(input,26,Follow._26_in_literal606);  
				stream_26.Add(char_literal70);

				DebugLocation(96, 11);
				PushFollow(Follow._cond_exp_in_literal608);
				cond_exp71=cond_exp();
				PopFollow();

				stream_cond_exp.Add(cond_exp71.Tree);
				DebugLocation(96, 20);
				char_literal72=(IToken)Match(input,27,Follow._27_in_literal610);  
				stream_27.Add(char_literal72);



				{
				// AST REWRITE
				// elements: cond_exp
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 96:24: -> cond_exp
				{
					DebugLocation(96, 27);
					adaptor.AddChild(root_0, stream_cond_exp.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literal", 24);
			LeaveRule("literal", 24);
			LeaveRule_literal();
		}
		DebugLocation(96, 34);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return retval;

	}
	// $ANTLR end "literal"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _data_temp_line_in_data_temp115 = new BitSet(new ulong[]{0x3E00000000002UL});
		public static readonly BitSet _data_line_decl_in_data_temp_line134 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_data_temp_line136 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _byte_decl_in_data_line_decl145 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _word_decl_in_data_line_decl153 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dword_decl_in_data_line_decl161 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _qword_decl_in_data_line_decl169 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_decl_in_data_line_decl177 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _45_in_byte_decl186 = new BitSet(new ulong[]{0x40004000002UL});
		public static readonly BitSet _func_decl_in_byte_decl189 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _arr_decl_in_byte_decl192 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _49_in_word_decl201 = new BitSet(new ulong[]{0x40004000002UL});
		public static readonly BitSet _func_decl_in_word_decl204 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _arr_decl_in_word_decl207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _46_in_dword_decl216 = new BitSet(new ulong[]{0x40004000002UL});
		public static readonly BitSet _func_decl_in_dword_decl219 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _arr_decl_in_dword_decl222 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _47_in_qword_decl231 = new BitSet(new ulong[]{0x40004000002UL});
		public static readonly BitSet _func_decl_in_qword_decl234 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _arr_decl_in_qword_decl237 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _48_in_string_decl246 = new BitSet(new ulong[]{0x40004000002UL});
		public static readonly BitSet _func_decl_in_string_decl249 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _arr_decl_in_string_decl252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _26_in_func_decl262 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _expression_in_func_decl264 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_func_decl266 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_arr_decl282 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _expression_in_arr_decl284 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_arr_decl286 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cond_exp_in_expression303 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bool_or_exp_in_cond_exp320 = new BitSet(new ulong[]{0x20000000002UL});
		public static readonly BitSet _41_in_cond_exp323 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _cond_exp_in_cond_exp330 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _32_in_cond_exp332 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _cond_exp_in_cond_exp335 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bool_and_exp_in_bool_or_exp345 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _51_in_bool_or_exp347 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _bool_or_exp_in_bool_or_exp354 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _or_exp_in_bool_and_exp363 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _24_in_bool_and_exp367 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _bool_and_exp_in_bool_and_exp374 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xor_exp_in_or_exp385 = new BitSet(new ulong[]{0x4000000000002UL});
		public static readonly BitSet _50_in_or_exp389 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _or_exp_in_or_exp396 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _and_exp_in_xor_exp407 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _44_in_xor_exp411 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _xor_exp_in_xor_exp418 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equals_exp_in_and_exp429 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _25_in_and_exp432 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _and_exp_in_and_exp439 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _compare_exp_in_equals_exp449 = new BitSet(new ulong[]{0x2000400002UL});
		public static readonly BitSet _set_in_equals_exp452 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _equals_exp_in_equals_exp461 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shift_exp_in_compare_exp471 = new BitSet(new ulong[]{0xD400000002UL});
		public static readonly BitSet _set_in_compare_exp474 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _compare_exp_in_compare_exp485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _add_exp_in_shift_exp495 = new BitSet(new ulong[]{0x10800000002UL});
		public static readonly BitSet _set_in_shift_exp499 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _shift_exp_in_shift_exp508 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multiply_exp_in_add_exp519 = new BitSet(new ulong[]{0x60000002UL});
		public static readonly BitSet _set_in_add_exp521 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _add_exp_in_add_exp531 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unary_exp_in_multiply_exp540 = new BitSet(new ulong[]{0x90800002UL});
		public static readonly BitSet _set_in_multiply_exp543 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _multiply_exp_in_multiply_exp554 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literal_in_unary_exp564 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_unary_exp572 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _unary_exp_in_unary_exp581 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_literal590 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _26_in_literal606 = new BitSet(new ulong[]{0x10000044208000UL});
		public static readonly BitSet _cond_exp_in_literal608 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_literal610 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace GBRead.Base
